{"ast":null,"code":"// community-modules/client-side-row-model/src/clientSideRowModelModule.ts\nimport { _defineModule } from \"@ag-grid-community/core\";\nimport { ModuleNames, RowModelHelperService, _CsrmSsrmSharedApiModule } from \"@ag-grid-community/core\";\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModel.ts\nimport { BeanStub, ChangedPath, ClientSideRowModelSteps, RowHighlightPosition, RowNode as RowNode2, _debounce, _errorOnce as _errorOnce2, _exists, _getGrandTotalRow, _getGroupSelectsDescendants, _getGroupTotalRowCallback, _getRowHeightForNode, _insertIntoArray, _isAnimateRows, _isDomLayout, _last, _missing, _missingOrEmpty as _missingOrEmpty2, _removeFromArray } from \"@ag-grid-community/core\";\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideNodeManager.ts\nimport { RowNode, _cloneObject, _errorOnce, _getRowIdCallback, _missingOrEmpty, _warnOnce } from \"@ag-grid-community/core\";\nvar ROOT_NODE_ID = \"ROOT_NODE_ID\";\nvar TOP_LEVEL = 0;\nvar ClientSideNodeManager = class {\n  constructor(rootNode, gos, eventService, funcColsService, selectionService, beans) {\n    this.nextId = 0;\n    // has row data actually been set\n    this.rowCountReady = false;\n    // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n    this.allNodesMap = {};\n    this.rootNode = rootNode;\n    this.gos = gos;\n    this.eventService = eventService;\n    this.funcColsService = funcColsService;\n    this.beans = beans;\n    this.selectionService = selectionService;\n    this.rootNode.group = true;\n    this.rootNode.level = -1;\n    this.rootNode.id = ROOT_NODE_ID;\n    this.rootNode.allLeafChildren = [];\n    this.rootNode.childrenAfterGroup = [];\n    this.rootNode.childrenAfterSort = [];\n    this.rootNode.childrenAfterAggFilter = [];\n    this.rootNode.childrenAfterFilter = [];\n  }\n  getCopyOfNodesMap() {\n    return _cloneObject(this.allNodesMap);\n  }\n  getRowNode(id) {\n    return this.allNodesMap[id];\n  }\n  setRowData(rowData) {\n    if (typeof rowData === \"string\") {\n      _warnOnce(\"rowData must be an array.\");\n      return;\n    }\n    this.rowCountReady = true;\n    this.dispatchRowDataUpdateStartedEvent(rowData);\n    const rootNode = this.rootNode;\n    const sibling = this.rootNode.sibling;\n    rootNode.childrenAfterFilter = null;\n    rootNode.childrenAfterGroup = null;\n    rootNode.childrenAfterAggFilter = null;\n    rootNode.childrenAfterSort = null;\n    rootNode.childrenMapped = null;\n    rootNode.updateHasChildren();\n    this.nextId = 0;\n    this.allNodesMap = {};\n    if (rowData) {\n      rootNode.allLeafChildren = rowData.map((dataItem, index) => this.createNode(dataItem, this.rootNode, TOP_LEVEL, index));\n    } else {\n      rootNode.allLeafChildren = [];\n      rootNode.childrenAfterGroup = [];\n    }\n    if (sibling) {\n      sibling.childrenAfterFilter = rootNode.childrenAfterFilter;\n      sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n      sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;\n      sibling.childrenAfterSort = rootNode.childrenAfterSort;\n      sibling.childrenMapped = rootNode.childrenMapped;\n      sibling.allLeafChildren = rootNode.allLeafChildren;\n    }\n  }\n  updateRowData(rowDataTran) {\n    this.rowCountReady = true;\n    this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);\n    const updateRowDataResult = {\n      rowNodeTransaction: {\n        remove: [],\n        update: [],\n        add: []\n      },\n      rowsInserted: false\n    };\n    const nodesToUnselect = [];\n    this.executeRemove(rowDataTran, updateRowDataResult, nodesToUnselect);\n    this.executeUpdate(rowDataTran, updateRowDataResult, nodesToUnselect);\n    this.executeAdd(rowDataTran, updateRowDataResult);\n    this.updateSelection(nodesToUnselect, \"rowDataChanged\");\n    return updateRowDataResult;\n  }\n  /**\n   * Used by the immutable service, after updateRowData, after updating with a generated transaction to\n   * apply the order as specified by the the new data. We use sourceRowIndex to determine the order of the rows.\n   * Time complexity is O(n) where n is the number of rows/rowData\n   * @returns true if the order changed, otherwise false\n   */\n  updateRowOrderFromRowData(rowData) {\n    const rows = this.rootNode.allLeafChildren;\n    const rowsLength = rows?.length ?? 0;\n    const rowsOutOfOrder = /* @__PURE__ */new Map();\n    let firstIndexOutOfOrder = -1;\n    let lastIndexOutOfOrder = -1;\n    for (let i = 0; i < rowsLength; ++i) {\n      const row = rows[i];\n      const data = row.data;\n      if (data !== rowData[i]) {\n        if (lastIndexOutOfOrder < 0) {\n          firstIndexOutOfOrder = i;\n        }\n        lastIndexOutOfOrder = i;\n        rowsOutOfOrder.set(data, row);\n      }\n    }\n    if (firstIndexOutOfOrder < 0) {\n      return false;\n    }\n    for (let i = firstIndexOutOfOrder; i <= lastIndexOutOfOrder; ++i) {\n      const row = rowsOutOfOrder.get(rowData[i]);\n      if (row !== void 0) {\n        rows[i] = row;\n        row.sourceRowIndex = i;\n      }\n    }\n    return true;\n  }\n  isRowCountReady() {\n    return this.rowCountReady;\n  }\n  dispatchRowDataUpdateStartedEvent(rowData) {\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdateStarted\",\n      firstRowData: rowData?.length ? rowData[0] : null\n    });\n  }\n  updateSelection(nodesToUnselect, source) {\n    const selectionChanged = nodesToUnselect.length > 0;\n    if (selectionChanged) {\n      this.selectionService.setNodesSelected({\n        newValue: false,\n        nodes: nodesToUnselect,\n        suppressFinishActions: true,\n        source\n      });\n    }\n    this.selectionService.updateGroupsFromChildrenSelections(source);\n    if (selectionChanged) {\n      this.eventService.dispatchEvent({\n        type: \"selectionChanged\",\n        source\n      });\n    }\n  }\n  executeAdd(rowDataTran, result) {\n    const add = rowDataTran.add;\n    if (_missingOrEmpty(add)) {\n      return;\n    }\n    const allLeafChildren = this.rootNode.allLeafChildren;\n    let addIndex = allLeafChildren.length;\n    if (typeof rowDataTran.addIndex === \"number\") {\n      addIndex = this.sanitizeAddIndex(rowDataTran.addIndex);\n      if (addIndex > 0) {\n        const isTreeData = this.gos.get(\"treeData\");\n        if (isTreeData) {\n          for (let i = 0; i < allLeafChildren.length; i++) {\n            const node = allLeafChildren[i];\n            if (node?.rowIndex == addIndex - 1) {\n              addIndex = i + 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    const newNodes = add.map((item, index) => this.createNode(item, this.rootNode, TOP_LEVEL, addIndex + index));\n    if (addIndex < allLeafChildren.length) {\n      const nodesBeforeIndex = allLeafChildren.slice(0, addIndex);\n      const nodesAfterIndex = allLeafChildren.slice(addIndex, allLeafChildren.length);\n      const nodesAfterIndexFirstIndex = nodesBeforeIndex.length + newNodes.length;\n      for (let index = 0, length = nodesAfterIndex.length; index < length; ++index) {\n        nodesAfterIndex[index].sourceRowIndex = nodesAfterIndexFirstIndex + index;\n      }\n      this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];\n      result.rowsInserted = true;\n    } else {\n      this.rootNode.allLeafChildren = allLeafChildren.concat(newNodes);\n    }\n    const sibling = this.rootNode.sibling;\n    if (sibling) {\n      sibling.allLeafChildren = allLeafChildren;\n    }\n    result.rowNodeTransaction.add = newNodes;\n  }\n  sanitizeAddIndex(addIndex) {\n    const allChildrenCount = this.rootNode.allLeafChildren?.length ?? 0;\n    if (addIndex < 0 || addIndex >= allChildrenCount || Number.isNaN(addIndex)) {\n      return allChildrenCount;\n    }\n    return Math.ceil(addIndex);\n  }\n  executeRemove(rowDataTran, {\n    rowNodeTransaction\n  }, nodesToUnselect) {\n    const {\n      remove\n    } = rowDataTran;\n    if (_missingOrEmpty(remove)) {\n      return;\n    }\n    const rowIdsRemoved = {};\n    remove.forEach(item => {\n      const rowNode = this.lookupRowNode(item);\n      if (!rowNode) {\n        return;\n      }\n      if (rowNode.isSelected()) {\n        nodesToUnselect.push(rowNode);\n      }\n      rowNode.clearRowTopAndRowIndex();\n      rowIdsRemoved[rowNode.id] = true;\n      delete this.allNodesMap[rowNode.id];\n      rowNodeTransaction.remove.push(rowNode);\n    });\n    this.rootNode.allLeafChildren = this.rootNode.allLeafChildren?.filter(rowNode => !rowIdsRemoved[rowNode.id]) ?? null;\n    this.rootNode.allLeafChildren?.forEach((node, idx) => {\n      node.sourceRowIndex = idx;\n    });\n    const sibling = this.rootNode.sibling;\n    if (sibling) {\n      sibling.allLeafChildren = this.rootNode.allLeafChildren;\n    }\n  }\n  executeUpdate(rowDataTran, {\n    rowNodeTransaction\n  }, nodesToUnselect) {\n    const {\n      update\n    } = rowDataTran;\n    if (_missingOrEmpty(update)) {\n      return;\n    }\n    update.forEach(item => {\n      const rowNode = this.lookupRowNode(item);\n      if (!rowNode) {\n        return;\n      }\n      rowNode.updateData(item);\n      if (!rowNode.selectable && rowNode.isSelected()) {\n        nodesToUnselect.push(rowNode);\n      }\n      this.setMasterForRow(rowNode, item, TOP_LEVEL, false);\n      rowNodeTransaction.update.push(rowNode);\n    });\n  }\n  lookupRowNode(data) {\n    const getRowIdFunc = _getRowIdCallback(this.gos);\n    let rowNode;\n    if (getRowIdFunc) {\n      const id = getRowIdFunc({\n        data,\n        level: 0\n      });\n      rowNode = this.allNodesMap[id];\n      if (!rowNode) {\n        _errorOnce(`could not find row id=${id}, data item was not found for this id`);\n        return null;\n      }\n    } else {\n      rowNode = this.rootNode.allLeafChildren?.find(node => node.data === data);\n      if (!rowNode) {\n        _errorOnce(`could not find data item as object was not found`, data);\n        _errorOnce(`Consider using getRowId to help the Grid find matching row data`);\n        return null;\n      }\n    }\n    return rowNode || null;\n  }\n  createNode(dataItem, parent, level, sourceRowIndex) {\n    const node = new RowNode(this.beans);\n    node.sourceRowIndex = sourceRowIndex;\n    node.group = false;\n    this.setMasterForRow(node, dataItem, level, true);\n    if (parent) {\n      node.parent = parent;\n    }\n    node.level = level;\n    node.setDataAndId(dataItem, this.nextId.toString());\n    if (this.allNodesMap[node.id]) {\n      _warnOnce(`duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);\n    }\n    this.allNodesMap[node.id] = node;\n    this.nextId++;\n    return node;\n  }\n  setMasterForRow(rowNode, data, level, setExpanded) {\n    const isTreeData = this.gos.get(\"treeData\");\n    if (isTreeData) {\n      rowNode.setMaster(false);\n      if (setExpanded) {\n        rowNode.expanded = false;\n      }\n    } else {\n      const masterDetail = this.gos.get(\"masterDetail\");\n      if (masterDetail) {\n        const isRowMasterFunc = this.gos.get(\"isRowMaster\");\n        if (isRowMasterFunc) {\n          rowNode.setMaster(isRowMasterFunc(data));\n        } else {\n          rowNode.setMaster(true);\n        }\n      } else {\n        rowNode.setMaster(false);\n      }\n      if (setExpanded) {\n        const rowGroupColumns = this.funcColsService.getRowGroupColumns();\n        const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\n        const masterRowLevel = level + numRowGroupColumns;\n        rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;\n      }\n    }\n  }\n  isExpanded(level) {\n    const expandByDefault = this.gos.get(\"groupDefaultExpanded\");\n    if (expandByDefault === -1) {\n      return true;\n    }\n    return level < expandByDefault;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModel.ts\nvar ClientSideRowModel = class extends BeanStub {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"rowModel\";\n    this.onRowHeightChanged_debounced = _debounce(this.onRowHeightChanged.bind(this), 100);\n    this.rowsToDisplay = [];\n    /** Has the start method been called */\n    this.hasStarted = false;\n    /** E.g. data has been set into the node manager already */\n    this.shouldSkipSettingDataOnStart = false;\n    /**\n     * This is to prevent refresh model being called when it's already being called.\n     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,\n     * which then triggers the listener here that calls refresh model again but at the filter stage\n     * (which is about to be run by the original call).\n     */\n    this.isRefreshingModel = false;\n    this.rowCountReady = false;\n  }\n  wireBeans(beans) {\n    this.beans = beans;\n    this.columnModel = beans.columnModel;\n    this.funcColsService = beans.funcColsService;\n    this.selectionService = beans.selectionService;\n    this.valueCache = beans.valueCache;\n    this.environment = beans.environment;\n    this.filterStage = beans.filterStage;\n    this.sortStage = beans.sortStage;\n    this.flattenStage = beans.flattenStage;\n    this.groupStage = beans.groupStage;\n    this.aggregationStage = beans.aggregationStage;\n    this.pivotStage = beans.pivotStage;\n    this.filterAggregatesStage = beans.filterAggregatesStage;\n  }\n  postConstruct() {\n    const refreshEverythingFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING\n    });\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING,\n      // after cols change, row grouping (the first stage) could of changed\n      afterColumnsChanged: true,\n      keepRenderedRows: true,\n      // we want animations cos sorting or filtering could be applied\n      animate\n    });\n    this.addManagedEventListeners({\n      newColumnsLoaded: refreshEverythingAfterColsChangedFunc,\n      columnRowGroupChanged: refreshEverythingFunc,\n      columnValueChanged: this.onValueChanged.bind(this),\n      columnPivotChanged: this.refreshModel.bind(this, {\n        step: ClientSideRowModelSteps.PIVOT\n      }),\n      filterChanged: this.onFilterChanged.bind(this),\n      sortChanged: this.onSortChanged.bind(this),\n      columnPivotModeChanged: refreshEverythingFunc,\n      gridStylesChanged: this.onGridStylesChanges.bind(this),\n      gridReady: this.onGridReady.bind(this)\n    });\n    this.addPropertyListeners();\n    this.rootNode = new RowNode2(this.beans);\n    this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gos, this.eventService, this.funcColsService, this.selectionService, this.beans);\n  }\n  addPropertyListeners() {\n    const resetProps = /* @__PURE__ */new Set([\"treeData\", \"masterDetail\"]);\n    const groupStageRefreshProps = /* @__PURE__ */new Set([\"groupDefaultExpanded\", \"groupAllowUnbalanced\", \"initialGroupOrderComparator\", \"groupHideOpenParents\", \"groupDisplayType\"]);\n    const filterStageRefreshProps = /* @__PURE__ */new Set([\"excludeChildrenWhenTreeDataFiltering\"]);\n    const pivotStageRefreshProps = /* @__PURE__ */new Set([\"removePivotHeaderRowWhenSingleValueColumn\", \"pivotRowTotals\", \"pivotColumnGroupTotals\", \"suppressExpandablePivotGroups\"]);\n    const aggregateStageRefreshProps = /* @__PURE__ */new Set([\"getGroupRowAgg\", \"alwaysAggregateAtRootLevel\", \"groupIncludeTotalFooter\", \"suppressAggFilteredOnly\", \"grandTotalRow\"]);\n    const sortStageRefreshProps = /* @__PURE__ */new Set([\"postSortRows\", \"groupDisplayType\", \"accentedSort\"]);\n    const filterAggStageRefreshProps = /* @__PURE__ */new Set([]);\n    const flattenStageRefreshProps = /* @__PURE__ */new Set([\"groupRemoveSingleChildren\", \"groupRemoveLowestSingleChildren\", \"groupIncludeFooter\", \"groupTotalRow\"]);\n    const allProps = [...resetProps, ...groupStageRefreshProps, ...filterStageRefreshProps, ...pivotStageRefreshProps, ...pivotStageRefreshProps, ...aggregateStageRefreshProps, ...sortStageRefreshProps, ...filterAggStageRefreshProps, ...flattenStageRefreshProps];\n    this.addManagedPropertyListeners(allProps, params => {\n      const properties = params.changeSet?.properties;\n      if (!properties) {\n        return;\n      }\n      const arePropertiesImpacted = propSet => properties.some(prop => propSet.has(prop));\n      if (arePropertiesImpacted(resetProps)) {\n        this.setRowData(this.rootNode.allLeafChildren.map(child => child.data));\n        return;\n      }\n      if (arePropertiesImpacted(groupStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.EVERYTHING\n        });\n        return;\n      }\n      if (arePropertiesImpacted(filterStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.FILTER\n        });\n        return;\n      }\n      if (arePropertiesImpacted(pivotStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.PIVOT\n        });\n        return;\n      }\n      if (arePropertiesImpacted(aggregateStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.AGGREGATE\n        });\n        return;\n      }\n      if (arePropertiesImpacted(sortStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.SORT\n        });\n        return;\n      }\n      if (arePropertiesImpacted(filterAggStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.FILTER_AGGREGATES\n        });\n        return;\n      }\n      if (arePropertiesImpacted(flattenStageRefreshProps)) {\n        this.refreshModel({\n          step: ClientSideRowModelSteps.MAP\n        });\n      }\n    });\n    this.addManagedPropertyListener(\"rowHeight\", () => this.resetRowHeights());\n  }\n  start() {\n    this.hasStarted = true;\n    if (this.shouldSkipSettingDataOnStart) {\n      this.dispatchUpdateEventsAndRefresh();\n    } else {\n      this.setInitialData();\n    }\n  }\n  setInitialData() {\n    const rowData = this.gos.get(\"rowData\");\n    if (rowData) {\n      this.shouldSkipSettingDataOnStart = true;\n      this.setRowData(rowData);\n    }\n  }\n  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    let atLeastOneChange;\n    let res = false;\n    do {\n      atLeastOneChange = false;\n      const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n      const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n      const firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n      const lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n      for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n        const rowNode = this.getRow(rowIndex);\n        if (rowNode.rowHeightEstimated) {\n          const rowHeight = _getRowHeightForNode(this.gos, rowNode);\n          rowNode.setRowHeight(rowHeight.height);\n          atLeastOneChange = true;\n          res = true;\n        }\n      }\n      if (atLeastOneChange) {\n        this.setRowTopAndRowIndex();\n      }\n    } while (atLeastOneChange);\n    return res;\n  }\n  setRowTopAndRowIndex() {\n    const defaultRowHeight = this.environment.getDefaultRowHeight();\n    let nextRowTop = 0;\n    const displayedRowsMapped = /* @__PURE__ */new Set();\n    const allowEstimate = _isDomLayout(this.gos, \"normal\");\n    for (let i = 0; i < this.rowsToDisplay.length; i++) {\n      const rowNode = this.rowsToDisplay[i];\n      if (rowNode.id != null) {\n        displayedRowsMapped.add(rowNode.id);\n      }\n      if (rowNode.rowHeight == null) {\n        const rowHeight = _getRowHeightForNode(this.gos, rowNode, allowEstimate, defaultRowHeight);\n        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n      }\n      rowNode.setRowTop(nextRowTop);\n      rowNode.setRowIndex(i);\n      nextRowTop += rowNode.rowHeight;\n    }\n    return displayedRowsMapped;\n  }\n  clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {\n    const changedPathActive = changedPath.isActive();\n    const clearIfNotDisplayed = rowNode => {\n      if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n        rowNode.clearRowTopAndRowIndex();\n      }\n    };\n    const recurse = rowNode => {\n      clearIfNotDisplayed(rowNode);\n      clearIfNotDisplayed(rowNode.detailNode);\n      clearIfNotDisplayed(rowNode.sibling);\n      if (rowNode.hasChildren()) {\n        if (rowNode.childrenAfterGroup) {\n          const isRootNode = rowNode.level == -1;\n          const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n          if (!skipChildren) {\n            rowNode.childrenAfterGroup.forEach(recurse);\n          }\n        }\n      }\n    };\n    recurse(this.rootNode);\n  }\n  // returns false if row was moved, otherwise true\n  ensureRowsAtPixel(rowNodes, pixel, increment = 0) {\n    const indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n    const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    if (rowNodeAtPixelNow === rowNodes[0]) {\n      return false;\n    }\n    const allLeafChildren = this.rootNode.allLeafChildren;\n    rowNodes.forEach(rowNode => {\n      _removeFromArray(allLeafChildren, rowNode);\n    });\n    rowNodes.forEach((rowNode, idx) => {\n      _insertIntoArray(allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n    });\n    rowNodes.forEach((rowNode, index) => {\n      rowNode.sourceRowIndex = index;\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate,\n      rowNodesOrderChanged: true\n      // We assume the order changed and we don't need to check if it really did\n    });\n    return true;\n  }\n  highlightRowAtPixel(rowNode, pixel) {\n    const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n    const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n    if (!rowNodeAtPixelNow || !rowNode || pixel == null) {\n      this.clearHighlightedRow();\n      return;\n    }\n    const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n    const isSamePosition = this.isHighlightingCurrentPosition(rowNode, rowNodeAtPixelNow, highlight);\n    const isDifferentNode = this.lastHighlightedRow != null && this.lastHighlightedRow !== rowNodeAtPixelNow;\n    if (isSamePosition || isDifferentNode) {\n      this.clearHighlightedRow();\n      if (isSamePosition) {\n        return;\n      }\n    }\n    rowNodeAtPixelNow.setHighlighted(highlight);\n    this.lastHighlightedRow = rowNodeAtPixelNow;\n  }\n  getHighlightPosition(pixel, rowNode) {\n    if (!rowNode) {\n      const index = this.getRowIndexAtPixel(pixel);\n      rowNode = this.getRow(index || 0);\n      if (!rowNode) {\n        return RowHighlightPosition.Below;\n      }\n    }\n    const {\n      rowTop,\n      rowHeight\n    } = rowNode;\n    return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n  }\n  getLastHighlightedRowNode() {\n    return this.lastHighlightedRow;\n  }\n  isHighlightingCurrentPosition(movingRowNode, hoveredRowNode, highlightPosition) {\n    if (movingRowNode === hoveredRowNode) {\n      return true;\n    }\n    const diff = highlightPosition === RowHighlightPosition.Above ? -1 : 1;\n    if (this.getRow(hoveredRowNode.rowIndex + diff) === movingRowNode) {\n      return true;\n    }\n    return false;\n  }\n  clearHighlightedRow() {\n    if (this.lastHighlightedRow) {\n      this.lastHighlightedRow.setHighlighted(null);\n      this.lastHighlightedRow = null;\n    }\n  }\n  isLastRowIndexKnown() {\n    return true;\n  }\n  getRowCount() {\n    if (this.rowsToDisplay) {\n      return this.rowsToDisplay.length;\n    }\n    return 0;\n  }\n  /**\n   * Returns the number of rows with level === 1\n   */\n  getTopLevelRowCount() {\n    if (this.rowsToDisplay.length === 0) {\n      return 0;\n    }\n    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n    if (showingRootNode) {\n      return 1;\n    }\n    const filteredChildren = this.rootNode.childrenAfterAggFilter;\n    const totalFooterInc = this.rootNode.sibling ? 1 : 0;\n    return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;\n  }\n  /**\n   * Get the row display index by the top level index\n   * top level index is the index of rows with level === 1\n   */\n  getTopLevelRowDisplayedIndex(topLevelIndex) {\n    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n    if (showingRootNode) {\n      return topLevelIndex;\n    }\n    let adjustedIndex = topLevelIndex;\n    if (this.rowsToDisplay[0].footer) {\n      if (topLevelIndex === 0) {\n        return 0;\n      }\n      adjustedIndex -= 1;\n    }\n    const lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];\n    const indexOutsideGroupBounds = adjustedIndex >= this.rootNode.childrenAfterSort.length;\n    if (lastRow.footer && indexOutsideGroupBounds) {\n      return lastRow.rowIndex;\n    }\n    let rowNode = this.rootNode.childrenAfterSort[adjustedIndex];\n    if (this.gos.get(\"groupHideOpenParents\")) {\n      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n        rowNode = rowNode.childrenAfterSort[0];\n      }\n    }\n    return rowNode.rowIndex;\n  }\n  getRowBounds(index) {\n    if (_missing(this.rowsToDisplay)) {\n      return null;\n    }\n    const rowNode = this.rowsToDisplay[index];\n    if (rowNode) {\n      return {\n        rowTop: rowNode.rowTop,\n        rowHeight: rowNode.rowHeight\n      };\n    }\n    return null;\n  }\n  onRowGroupOpened() {\n    const animate = _isAnimateRows(this.gos);\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      animate\n    });\n  }\n  onFilterChanged(event) {\n    if (event.afterDataChange) {\n      return;\n    }\n    const animate = _isAnimateRows(this.gos);\n    const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some(col => col.isPrimary());\n    const step = primaryOrQuickFilterChanged ? ClientSideRowModelSteps.FILTER : ClientSideRowModelSteps.FILTER_AGGREGATES;\n    this.refreshModel({\n      step,\n      keepRenderedRows: true,\n      animate\n    });\n  }\n  onSortChanged() {\n    const animate = _isAnimateRows(this.gos);\n    this.refreshModel({\n      step: ClientSideRowModelSteps.SORT,\n      keepRenderedRows: true,\n      animate,\n      keepEditingRows: true\n    });\n  }\n  getType() {\n    return \"clientSide\";\n  }\n  onValueChanged() {\n    if (this.columnModel.isPivotActive()) {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.PIVOT\n      });\n    } else {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.AGGREGATE\n      });\n    }\n  }\n  createChangePath(rowNodeTransactions) {\n    const noTransactions = _missingOrEmpty2(rowNodeTransactions);\n    const changedPath = new ChangedPath(false, this.rootNode);\n    if (noTransactions) {\n      changedPath.setInactive();\n    }\n    return changedPath;\n  }\n  isSuppressModelUpdateAfterUpdateTransaction(params) {\n    if (!this.gos.get(\"suppressModelUpdateAfterUpdateTransaction\")) {\n      return false;\n    }\n    if (params.rowNodeTransactions == null) {\n      return false;\n    }\n    const transWithAddsOrDeletes = params.rowNodeTransactions.filter(tx => tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0);\n    const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n    return transactionsContainUpdatesOnly;\n  }\n  buildRefreshModelParams(step) {\n    let paramsStep = ClientSideRowModelSteps.EVERYTHING;\n    const stepsMapped = {\n      everything: ClientSideRowModelSteps.EVERYTHING,\n      group: ClientSideRowModelSteps.EVERYTHING,\n      filter: ClientSideRowModelSteps.FILTER,\n      map: ClientSideRowModelSteps.MAP,\n      aggregate: ClientSideRowModelSteps.AGGREGATE,\n      filter_aggregates: ClientSideRowModelSteps.FILTER_AGGREGATES,\n      sort: ClientSideRowModelSteps.SORT,\n      pivot: ClientSideRowModelSteps.PIVOT,\n      nothing: ClientSideRowModelSteps.NOTHING\n    };\n    if (_exists(step)) {\n      paramsStep = stepsMapped[step];\n    }\n    if (_missing(paramsStep)) {\n      _errorOnce2(`invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(\", \")}`);\n      return void 0;\n    }\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    const modelParams = {\n      step: paramsStep,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate\n    };\n    return modelParams;\n  }\n  refreshModel(paramsOrStep) {\n    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching()) {\n      return;\n    }\n    const params = typeof paramsOrStep === \"object\" && \"step\" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);\n    if (!params) {\n      return;\n    }\n    if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n      return;\n    }\n    const changedPath = this.createChangePath(params.rowNodeTransactions);\n    this.isRefreshingModel = true;\n    switch (params.step) {\n      case ClientSideRowModelSteps.EVERYTHING:\n        this.doRowGrouping(params.rowNodeTransactions, changedPath, !!params.rowNodesOrderChanged, !!params.afterColumnsChanged);\n      case ClientSideRowModelSteps.FILTER:\n        this.doFilter(changedPath);\n      case ClientSideRowModelSteps.PIVOT:\n        this.doPivot(changedPath);\n      case ClientSideRowModelSteps.AGGREGATE:\n        this.doAggregate(changedPath);\n      case ClientSideRowModelSteps.FILTER_AGGREGATES:\n        this.doFilterAggregates(changedPath);\n      case ClientSideRowModelSteps.SORT:\n        this.doSort(params.rowNodeTransactions, changedPath);\n      case ClientSideRowModelSteps.MAP:\n        this.doRowsToDisplay();\n    }\n    const displayedNodesMapped = this.setRowTopAndRowIndex();\n    this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n    this.isRefreshingModel = false;\n    this.eventService.dispatchEvent({\n      type: \"modelUpdated\",\n      animate: params.animate,\n      keepRenderedRows: params.keepRenderedRows,\n      newData: params.newData,\n      newPage: false,\n      keepUndoRedoStack: params.keepUndoRedoStack\n    });\n  }\n  isEmpty() {\n    const rowsMissing = _missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n    return _missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n  }\n  isRowsToRender() {\n    return _exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n  }\n  getNodesInRangeForSelection(firstInRange, lastInRange) {\n    let started = false;\n    let finished = false;\n    const result = [];\n    const groupsSelectChildren = _getGroupSelectsDescendants(this.gos);\n    this.forEachNodeAfterFilterAndSort(rowNode => {\n      if (finished) {\n        return;\n      }\n      if (started) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          finished = true;\n          if (rowNode.group && groupsSelectChildren) {\n            result.push(...rowNode.allLeafChildren);\n            return;\n          }\n        }\n      }\n      if (!started) {\n        if (rowNode !== lastInRange && rowNode !== firstInRange) {\n          return;\n        }\n        started = true;\n      }\n      const includeThisNode = !rowNode.group || !groupsSelectChildren;\n      if (includeThisNode) {\n        result.push(rowNode);\n        return;\n      }\n    });\n    return result;\n  }\n  // eslint-disable-next-line\n  setDatasource(datasource) {\n    _errorOnce2(\"should never call setDatasource on clientSideRowController\");\n  }\n  getTopLevelNodes() {\n    return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n  }\n  getRootNode() {\n    return this.rootNode;\n  }\n  getRow(index) {\n    return this.rowsToDisplay[index];\n  }\n  isRowPresent(rowNode) {\n    return this.rowsToDisplay.indexOf(rowNode) >= 0;\n  }\n  getRowIndexAtPixel(pixelToMatch) {\n    if (this.isEmpty() || this.rowsToDisplay.length === 0) {\n      return -1;\n    }\n    let bottomPointer = 0;\n    let topPointer = this.rowsToDisplay.length - 1;\n    if (pixelToMatch <= 0) {\n      return 0;\n    }\n    const lastNode = _last(this.rowsToDisplay);\n    if (lastNode.rowTop <= pixelToMatch) {\n      return this.rowsToDisplay.length - 1;\n    }\n    let oldBottomPointer = -1;\n    let oldTopPointer = -1;\n    while (true) {\n      const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n      const currentRowNode = this.rowsToDisplay[midPointer];\n      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n        return midPointer;\n      }\n      if (currentRowNode.rowTop < pixelToMatch) {\n        bottomPointer = midPointer + 1;\n      } else if (currentRowNode.rowTop > pixelToMatch) {\n        topPointer = midPointer - 1;\n      }\n      const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;\n      if (caughtInInfiniteLoop) {\n        return midPointer;\n      }\n      oldBottomPointer = bottomPointer;\n      oldTopPointer = topPointer;\n    }\n  }\n  isRowInPixel(rowNode, pixelToMatch) {\n    const topPixel = rowNode.rowTop;\n    const bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n    const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n    return pixelInRow;\n  }\n  forEachLeafNode(callback) {\n    if (this.rootNode.allLeafChildren) {\n      this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));\n    }\n  }\n  forEachNode(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...(this.rootNode.childrenAfterGroup || [])],\n      callback,\n      recursionType: 0 /* Normal */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachNodeAfterFilter(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...(this.rootNode.childrenAfterAggFilter || [])],\n      callback,\n      recursionType: 1 /* AfterFilter */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...(this.rootNode.childrenAfterSort || [])],\n      callback,\n      recursionType: 2 /* AfterFilterAndSort */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachPivotNode(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [this.rootNode],\n      callback,\n      recursionType: 3 /* PivotNodes */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  // iterates through each item in memory, and calls the callback function\n  // nodes - the rowNodes to traverse\n  // callback - the user provided callback\n  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n  // index - works similar to the index in forEach in javascript's array function\n  recursivelyWalkNodesAndCallback(params) {\n    const {\n      nodes,\n      callback,\n      recursionType,\n      includeFooterNodes\n    } = params;\n    let {\n      index\n    } = params;\n    const addFooters = position => {\n      const parentNode = nodes[0]?.parent;\n      if (!parentNode) return;\n      const grandTotal = includeFooterNodes && _getGrandTotalRow(this.gos);\n      const isGroupIncludeFooter = _getGroupTotalRowCallback(this.gos);\n      const groupTotal = includeFooterNodes && isGroupIncludeFooter({\n        node: parentNode\n      });\n      const isRootNode = parentNode === this.rootNode;\n      if (isRootNode) {\n        if (grandTotal === position) {\n          parentNode.createFooter();\n          callback(parentNode.sibling, index++);\n        }\n        return;\n      }\n      if (groupTotal === position) {\n        parentNode.createFooter();\n        callback(parentNode.sibling, index++);\n      }\n    };\n    addFooters(\"top\");\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      callback(node, index++);\n      if (node.hasChildren() && !node.footer) {\n        let nodeChildren = null;\n        switch (recursionType) {\n          case 0 /* Normal */:\n            nodeChildren = node.childrenAfterGroup;\n            break;\n          case 1 /* AfterFilter */:\n            nodeChildren = node.childrenAfterAggFilter;\n            break;\n          case 2 /* AfterFilterAndSort */:\n            nodeChildren = node.childrenAfterSort;\n            break;\n          case 3 /* PivotNodes */:\n            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n            break;\n        }\n        if (nodeChildren) {\n          index = this.recursivelyWalkNodesAndCallback({\n            nodes: [...nodeChildren],\n            callback,\n            recursionType,\n            index,\n            includeFooterNodes\n          });\n        }\n      }\n    }\n    addFooters(\"bottom\");\n    return index;\n  }\n  // it's possible to recompute the aggregate without doing the other parts\n  // + api.refreshClientSideRowModel('aggregate')\n  doAggregate(changedPath) {\n    this.aggregationStage?.execute({\n      rowNode: this.rootNode,\n      changedPath\n    });\n  }\n  doFilterAggregates(changedPath) {\n    if (this.filterAggregatesStage) {\n      this.filterAggregatesStage.execute({\n        rowNode: this.rootNode,\n        changedPath\n      });\n    } else {\n      this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;\n    }\n  }\n  // + gridApi.expandAll()\n  // + gridApi.collapseAll()\n  expandOrCollapseAll(expand) {\n    const usingTreeData = this.gos.get(\"treeData\");\n    const usingPivotMode = this.columnModel.isPivotActive();\n    const recursiveExpandOrCollapse = rowNodes => {\n      if (!rowNodes) {\n        return;\n      }\n      rowNodes.forEach(rowNode => {\n        const actionRow = () => {\n          rowNode.expanded = expand;\n          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n        };\n        if (usingTreeData) {\n          const hasChildren = _exists(rowNode.childrenAfterGroup);\n          if (hasChildren) {\n            actionRow();\n          }\n          return;\n        }\n        if (usingPivotMode) {\n          const notLeafGroup = !rowNode.leafGroup;\n          if (notLeafGroup) {\n            actionRow();\n          }\n          return;\n        }\n        const isRowGroup = rowNode.group;\n        if (isRowGroup) {\n          actionRow();\n        }\n      });\n    };\n    if (this.rootNode) {\n      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n    }\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP\n    });\n    this.eventService.dispatchEvent({\n      type: \"expandOrCollapseAll\",\n      source: expand ? \"expandAll\" : \"collapseAll\"\n    });\n  }\n  doSort(rowNodeTransactions, changedPath) {\n    this.sortStage.execute({\n      rowNode: this.rootNode,\n      rowNodeTransactions,\n      changedPath\n    });\n  }\n  doRowGrouping(rowNodeTransactions, changedPath, rowNodesOrderChanged, afterColumnsChanged) {\n    if (this.groupStage) {\n      if (rowNodeTransactions) {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          rowNodeTransactions,\n          rowNodesOrderChanged,\n          changedPath\n        });\n      } else {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          changedPath,\n          afterColumnsChanged\n        });\n      }\n      if (_getGroupSelectsDescendants(this.gos)) {\n        const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections(\"rowGroupChanged\", changedPath);\n        if (selectionChanged) {\n          this.eventService.dispatchEvent({\n            type: \"selectionChanged\",\n            source: \"rowGroupChanged\"\n          });\n        }\n      }\n    } else {\n      const rootNode = this.rootNode;\n      const sibling = rootNode.sibling;\n      rootNode.childrenAfterGroup = rootNode.allLeafChildren;\n      if (sibling) {\n        sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n      }\n      this.rootNode.updateHasChildren();\n    }\n    if (this.nodeManager.isRowCountReady()) {\n      this.rowCountReady = true;\n      this.eventService.dispatchEventOnce({\n        type: \"rowCountReady\"\n      });\n    }\n  }\n  doFilter(changedPath) {\n    this.filterStage.execute({\n      rowNode: this.rootNode,\n      changedPath\n    });\n  }\n  doPivot(changedPath) {\n    this.pivotStage?.execute({\n      rowNode: this.rootNode,\n      changedPath\n    });\n  }\n  getNodeManager() {\n    return this.nodeManager;\n  }\n  getRowNode(id) {\n    const idIsGroup = typeof id == \"string\" && id.indexOf(RowNode2.ID_PREFIX_ROW_GROUP) == 0;\n    if (idIsGroup) {\n      let res = void 0;\n      this.forEachNode(node => {\n        if (node.id === id) {\n          res = node;\n        }\n      });\n      return res;\n    }\n    return this.nodeManager.getRowNode(id);\n  }\n  // rows: the rows to put into the model\n  setRowData(rowData) {\n    this.selectionService.reset(\"rowDataChanged\");\n    this.nodeManager.setRowData(rowData);\n    if (this.hasStarted) {\n      this.dispatchUpdateEventsAndRefresh();\n    }\n  }\n  dispatchUpdateEventsAndRefresh() {\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdated\"\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      newData: true\n    });\n  }\n  batchUpdateRowData(rowDataTransaction, callback) {\n    if (this.applyAsyncTransactionsTimeout == null) {\n      this.rowDataTransactionBatch = [];\n      const waitMillis = this.gos.get(\"asyncTransactionWaitMillis\");\n      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {\n        if (this.isAlive()) {\n          this.executeBatchUpdateRowData();\n        }\n      }, waitMillis);\n    }\n    this.rowDataTransactionBatch.push({\n      rowDataTransaction,\n      callback\n    });\n  }\n  flushAsyncTransactions() {\n    if (this.applyAsyncTransactionsTimeout != null) {\n      clearTimeout(this.applyAsyncTransactionsTimeout);\n      this.executeBatchUpdateRowData();\n    }\n  }\n  executeBatchUpdateRowData() {\n    this.valueCache.onDataChanged();\n    const callbackFuncsBound = [];\n    const rowNodeTrans = [];\n    let orderChanged = false;\n    this.rowDataTransactionBatch?.forEach(tranItem => {\n      const {\n        rowNodeTransaction,\n        rowsInserted\n      } = this.nodeManager.updateRowData(tranItem.rowDataTransaction);\n      if (rowsInserted) {\n        orderChanged = true;\n      }\n      rowNodeTrans.push(rowNodeTransaction);\n      if (tranItem.callback) {\n        callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTransaction));\n      }\n    });\n    this.commonUpdateRowData(rowNodeTrans, orderChanged);\n    if (callbackFuncsBound.length > 0) {\n      window.setTimeout(() => {\n        callbackFuncsBound.forEach(func => func());\n      }, 0);\n    }\n    if (rowNodeTrans.length > 0) {\n      this.eventService.dispatchEvent({\n        type: \"asyncTransactionsFlushed\",\n        results: rowNodeTrans\n      });\n    }\n    this.rowDataTransactionBatch = null;\n    this.applyAsyncTransactionsTimeout = void 0;\n  }\n  /**\n   * Used to apply transaction changes.\n   * Called by gridApi & rowDragFeature\n   */\n  updateRowData(rowDataTran) {\n    this.valueCache.onDataChanged();\n    const {\n      rowNodeTransaction,\n      rowsInserted\n    } = this.nodeManager.updateRowData(rowDataTran);\n    this.commonUpdateRowData([rowNodeTransaction], rowsInserted);\n    return rowNodeTransaction;\n  }\n  /**\n   * Used to apply generated transaction\n   */\n  afterImmutableDataChange(rowNodeTransaction, rowNodesOrderChanged) {\n    this.commonUpdateRowData([rowNodeTransaction], rowNodesOrderChanged);\n  }\n  /**\n   * Common to:\n   * - executeBatchUpdateRowData (batch transactions)\n   * - updateRowData (single transaction)\n   * - afterImmutableDataChange (generated transaction)\n   *\n   * @param rowNodeTrans - the transactions to apply\n   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex\n   */\n  commonUpdateRowData(rowNodeTransactions, rowNodesOrderChanged) {\n    if (!this.hasStarted) {\n      return;\n    }\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdated\"\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      rowNodeTransactions,\n      rowNodesOrderChanged,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate\n    });\n  }\n  doRowsToDisplay() {\n    this.rowsToDisplay = this.flattenStage.execute({\n      rowNode: this.rootNode\n    });\n  }\n  onRowHeightChanged() {\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      keepUndoRedoStack: true\n    });\n  }\n  /** This method is debounced. It is used for row auto-height. If we don't debounce,\n   * then the Row Models will end up recalculating each row position\n   * for each row height change and result in the Row Renderer laying out rows.\n   * This is particularly bad if using print layout, and showing eg 1,000 rows,\n   * each row will change it's height, causing Row Model to update 1,000 times.\n   */\n  onRowHeightChangedDebounced() {\n    this.onRowHeightChanged_debounced();\n  }\n  resetRowHeights() {\n    const atLeastOne = this.resetRowHeightsForAllRowNodes();\n    this.rootNode.setRowHeight(this.rootNode.rowHeight, true);\n    if (this.rootNode.sibling) {\n      this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);\n    }\n    if (atLeastOne) {\n      this.onRowHeightChanged();\n    }\n  }\n  resetRowHeightsForAllRowNodes() {\n    let atLeastOne = false;\n    this.forEachNode(rowNode => {\n      rowNode.setRowHeight(rowNode.rowHeight, true);\n      const detailNode = rowNode.detailNode;\n      if (detailNode) {\n        detailNode.setRowHeight(detailNode.rowHeight, true);\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);\n      }\n      atLeastOne = true;\n    });\n    return atLeastOne;\n  }\n  onGridStylesChanges(e) {\n    if (e.rowHeightChanged) {\n      if (this.columnModel.isAutoRowHeightActive()) {\n        return;\n      }\n      this.resetRowHeights();\n    }\n  }\n  onGridReady() {\n    if (this.hasStarted) {\n      return;\n    }\n    this.setInitialData();\n  }\n  isRowDataLoaded() {\n    return this.rowCountReady;\n  }\n  destroy() {\n    super.destroy();\n    this.clearHighlightedRow();\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModelApi.ts\nimport { _warnOnce as _warnOnce2 } from \"@ag-grid-community/core\";\nfunction onGroupExpandedOrCollapsed(beans) {\n  beans.expansionService.onGroupExpandedOrCollapsed();\n}\nfunction refreshClientSideRowModel(beans, step) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.refreshModel(step);\n}\nfunction isRowDataEmpty(beans) {\n  return beans.rowModelHelperService?.getClientSideRowModel()?.isEmpty() ?? true;\n}\nfunction forEachLeafNode(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachLeafNode(callback);\n}\nfunction forEachNodeAfterFilter(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilter(callback);\n}\nfunction forEachNodeAfterFilterAndSort(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilterAndSort(callback);\n}\nfunction resetRowHeights(beans) {\n  if (beans.columnModel.isAutoRowHeightActive()) {\n    _warnOnce2(\"calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.\");\n    return;\n  }\n  beans.rowModelHelperService?.getClientSideRowModel()?.resetRowHeights();\n}\nfunction applyTransaction(beans, rowDataTransaction) {\n  return beans.frameworkOverrides.wrapIncoming(() => beans.rowModelHelperService?.getClientSideRowModel()?.updateRowData(rowDataTransaction));\n}\nfunction applyTransactionAsync(beans, rowDataTransaction, callback) {\n  beans.frameworkOverrides.wrapIncoming(() => beans.rowModelHelperService?.getClientSideRowModel()?.batchUpdateRowData(rowDataTransaction, callback));\n}\nfunction flushAsyncTransactions(beans) {\n  beans.frameworkOverrides.wrapIncoming(() => beans.rowModelHelperService?.getClientSideRowModel()?.flushAsyncTransactions());\n}\nfunction getBestCostNodeSelection(beans) {\n  return beans.selectionService.getBestCostNodeSelection();\n}\n\n// community-modules/client-side-row-model/src/clientSideRowModel/filterStage.ts\nimport { BeanStub as BeanStub2 } from \"@ag-grid-community/core\";\nvar FilterStage = class extends BeanStub2 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"filterStage\";\n  }\n  wireBeans(beans) {\n    this.filterManager = beans.filterManager;\n  }\n  execute(params) {\n    const {\n      changedPath\n    } = params;\n    this.filter(changedPath);\n  }\n  filter(changedPath) {\n    const filterActive = !!this.filterManager?.isChildFilterPresent();\n    this.filterNodes(filterActive, changedPath);\n  }\n  filterNodes(filterActive, changedPath) {\n    const filterCallback = (rowNode, includeChildNodes) => {\n      if (rowNode.hasChildren()) {\n        if (filterActive && !includeChildNodes) {\n          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter(childNode => {\n            const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;\n            const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({\n              rowNode: childNode\n            });\n            return passBecauseChildren || passBecauseDataPasses;\n          });\n        } else {\n          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n        }\n      } else {\n        rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;\n      }\n    };\n    if (this.doingTreeDataFiltering()) {\n      const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {\n        if (rowNode.childrenAfterGroup) {\n          for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n            const childNode = rowNode.childrenAfterGroup[i];\n            const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({\n              rowNode: childNode\n            });\n            if (childNode.childrenAfterGroup) {\n              treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);\n            } else {\n              filterCallback(childNode, foundInParent);\n            }\n          }\n        }\n        filterCallback(rowNode, alreadyFoundInParent);\n      };\n      const treeDataFilterCallback = rowNode => treeDataDepthFirstFilter(rowNode, false);\n      changedPath.executeFromRootNode(treeDataFilterCallback);\n    } else {\n      const defaultFilterCallback = rowNode => filterCallback(rowNode, false);\n      changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);\n    }\n  }\n  doingTreeDataFiltering() {\n    return this.gos.get(\"treeData\") && !this.gos.get(\"excludeChildrenWhenTreeDataFiltering\");\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/flattenStage.ts\nimport { BeanStub as BeanStub3, RowNode as RowNode3, _exists as _exists2, _getGrandTotalRow as _getGrandTotalRow2, _getGroupTotalRowCallback as _getGroupTotalRowCallback2, _isGroupMultiAutoColumn, _missingOrEmpty as _missingOrEmpty3 } from \"@ag-grid-community/core\";\nvar FlattenStage = class extends BeanStub3 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"flattenStage\";\n  }\n  wireBeans(beans) {\n    this.beans = beans;\n    this.columnModel = beans.columnModel;\n  }\n  execute(params) {\n    const rootNode = params.rowNode;\n    const result = [];\n    const skipLeafNodes = this.columnModel.isPivotMode();\n    const showRootNode = skipLeafNodes && rootNode.leafGroup;\n    const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n    const details = this.getFlattenDetails();\n    this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);\n    const atLeastOneRowPresent = result.length > 0;\n    const includeGrandTotalRow = !showRootNode &&\n    // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n    atLeastOneRowPresent && details.grandTotalRow;\n    if (includeGrandTotalRow) {\n      rootNode.createFooter();\n      const addToTop = details.grandTotalRow === \"top\";\n      this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);\n    }\n    return result;\n  }\n  getFlattenDetails() {\n    const groupRemoveSingleChildren = this.gos.get(\"groupRemoveSingleChildren\");\n    const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gos.get(\"groupRemoveLowestSingleChildren\");\n    return {\n      groupRemoveLowestSingleChildren,\n      groupRemoveSingleChildren,\n      isGroupMultiAutoColumn: _isGroupMultiAutoColumn(this.gos),\n      hideOpenParents: this.gos.get(\"groupHideOpenParents\"),\n      grandTotalRow: _getGrandTotalRow2(this.gos),\n      groupTotalRow: _getGroupTotalRowCallback2(this.gos)\n    };\n  }\n  recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {\n    if (_missingOrEmpty3(rowsToFlatten)) {\n      return;\n    }\n    for (let i = 0; i < rowsToFlatten.length; i++) {\n      const rowNode = rowsToFlatten[i];\n      const isParent = rowNode.hasChildren();\n      const isSkippedLeafNode = skipLeafNodes && !isParent;\n      const isRemovedSingleChildrenGroup = details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;\n      const isRemovedLowestSingleChildrenGroup = details.groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;\n      const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n      const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;\n      const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n      if (thisRowShouldBeRendered) {\n        this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);\n      }\n      if (skipLeafNodes && rowNode.leafGroup) {\n        continue;\n      }\n      if (isParent) {\n        const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n        if (rowNode.expanded || excludedParent) {\n          const doesRowShowFooter = details.groupTotalRow({\n            node: rowNode\n          });\n          if (!doesRowShowFooter) {\n            rowNode.destroyFooter();\n          }\n          const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n          if (doesRowShowFooter === \"top\") {\n            rowNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n          }\n          this.recursivelyAddToRowsToDisplay(details, rowNode.childrenAfterSort, result, skipLeafNodes, uiLevelForChildren);\n          if (doesRowShowFooter === \"bottom\") {\n            rowNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n          }\n        }\n      } else if (rowNode.master && rowNode.expanded) {\n        const detailNode = this.createDetailNode(rowNode);\n        this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);\n      }\n    }\n  }\n  // duplicated method, it's also in floatingRowModel\n  addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel, addToTop) {\n    if (addToTop) {\n      result.unshift(rowNode);\n    } else {\n      result.push(rowNode);\n    }\n    rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);\n  }\n  createDetailNode(masterNode) {\n    if (_exists2(masterNode.detailNode)) {\n      return masterNode.detailNode;\n    }\n    const detailNode = new RowNode3(this.beans);\n    detailNode.detail = true;\n    detailNode.selectable = false;\n    detailNode.parent = masterNode;\n    if (_exists2(masterNode.id)) {\n      detailNode.id = \"detail_\" + masterNode.id;\n    }\n    detailNode.data = masterNode.data;\n    detailNode.level = masterNode.level + 1;\n    masterNode.detailNode = detailNode;\n    return detailNode;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/immutableService.ts\nimport { BeanStub as BeanStub4, _errorOnce as _errorOnce3, _exists as _exists3, _getRowIdCallback as _getRowIdCallback2, _isClientSideRowModel, _iterateObject } from \"@ag-grid-community/core\";\nvar ImmutableService = class extends BeanStub4 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"immutableService\";\n  }\n  wireBeans(beans) {\n    this.rowModel = beans.rowModel;\n    this.selectionService = beans.selectionService;\n  }\n  postConstruct() {\n    if (_isClientSideRowModel(this.gos)) {\n      this.clientSideRowModel = this.rowModel;\n      this.addManagedPropertyListener(\"rowData\", () => this.onRowDataUpdated());\n    }\n  }\n  isActive() {\n    const getRowIdProvided = this.gos.exists(\"getRowId\");\n    const resetRowDataOnUpdate = this.gos.get(\"resetRowDataOnUpdate\");\n    if (resetRowDataOnUpdate) {\n      return false;\n    }\n    return getRowIdProvided;\n  }\n  setRowData(rowData) {\n    const rowDataTransaction = this.createTransactionForRowData(rowData);\n    if (!rowDataTransaction) {\n      return;\n    }\n    const nodeManager = this.clientSideRowModel.getNodeManager();\n    const {\n      rowNodeTransaction,\n      rowsInserted\n    } = nodeManager.updateRowData(rowDataTransaction);\n    let orderChanged = false;\n    const suppressSortOrder = this.gos.get(\"suppressMaintainUnsortedOrder\");\n    if (!suppressSortOrder) {\n      orderChanged = nodeManager.updateRowOrderFromRowData(rowData);\n    }\n    this.clientSideRowModel.afterImmutableDataChange(rowNodeTransaction, orderChanged || rowsInserted);\n  }\n  /** Converts the setRowData() command to a transaction */\n  createTransactionForRowData(rowData) {\n    if (!_isClientSideRowModel(this.gos)) {\n      _errorOnce3(\"ImmutableService only works with ClientSideRowModel\");\n      return null;\n    }\n    const getRowIdFunc = _getRowIdCallback2(this.gos);\n    if (getRowIdFunc == null) {\n      _errorOnce3(\"ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!\");\n      return null;\n    }\n    const existingNodesMap = this.clientSideRowModel.getNodeManager().getCopyOfNodesMap();\n    const remove = [];\n    const update = [];\n    const add = [];\n    if (_exists3(rowData)) {\n      rowData.forEach(data => {\n        const id = getRowIdFunc({\n          data,\n          level: 0\n        });\n        const existingNode = existingNodesMap[id];\n        if (existingNode) {\n          const dataHasChanged = existingNode.data !== data;\n          if (dataHasChanged) {\n            update.push(data);\n          }\n          existingNodesMap[id] = void 0;\n        } else {\n          add.push(data);\n        }\n      });\n    }\n    _iterateObject(existingNodesMap, (id, rowNode) => {\n      if (rowNode) {\n        remove.push(rowNode.data);\n      }\n    });\n    return {\n      remove,\n      update,\n      add\n    };\n  }\n  onRowDataUpdated() {\n    const rowData = this.gos.get(\"rowData\");\n    if (!rowData) {\n      return;\n    }\n    if (this.isActive()) {\n      this.setRowData(rowData);\n    } else {\n      this.selectionService.reset(\"rowDataChanged\");\n      this.clientSideRowModel.setRowData(rowData);\n    }\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/sortService.ts\nimport { BeanStub as BeanStub5, _errorOnce as _errorOnce4, _missing as _missing2, _warnOnce as _warnOnce3 } from \"@ag-grid-community/core\";\nvar SortService = class extends BeanStub5 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sortService\";\n  }\n  wireBeans(beans) {\n    this.columnModel = beans.columnModel;\n    this.funcColsService = beans.funcColsService;\n    this.rowNodeSorter = beans.rowNodeSorter;\n    this.showRowGroupColsService = beans.showRowGroupColsService;\n  }\n  sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {\n    const groupMaintainOrder = this.gos.get(\"groupMaintainOrder\");\n    const groupColumnsPresent = this.columnModel.getCols().some(c => c.isRowGroupActive());\n    let allDirtyNodes = {};\n    if (useDeltaSort && rowNodeTransactions) {\n      allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);\n    }\n    const isPivotMode = this.columnModel.isPivotMode();\n    const postSortFunc = this.gos.getCallback(\"postSortRows\");\n    const callback = rowNode => {\n      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);\n      const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;\n      const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n      if (skipSortingGroups) {\n        const nextGroup = this.funcColsService.getRowGroupColumns()?.[rowNode.level + 1];\n        const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;\n        const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);\n        if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {\n          const indexedOrders = {};\n          rowNode.childrenAfterSort.forEach((node, idx) => {\n            indexedOrders[node.id] = idx;\n          });\n          childrenToBeSorted.sort((row1, row2) => (indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0));\n        }\n        rowNode.childrenAfterSort = childrenToBeSorted;\n      } else if (!sortActive || skipSortingPivotLeafs) {\n        rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);\n      } else if (useDeltaSort) {\n        rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);\n      } else {\n        rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n      }\n      this.updateChildIndexes(rowNode);\n      if (postSortFunc) {\n        const params = {\n          nodes: rowNode.childrenAfterSort\n        };\n        postSortFunc(params);\n      }\n    };\n    if (changedPath) {\n      changedPath.forEachChangedNodeDepthFirst(callback);\n    }\n    this.updateGroupDataForHideOpenParents(changedPath);\n  }\n  calculateDirtyNodes(rowNodeTransactions) {\n    const dirtyNodes = {};\n    const addNodesFunc = rowNodes => {\n      if (rowNodes) {\n        rowNodes.forEach(rowNode => dirtyNodes[rowNode.id] = true);\n      }\n    };\n    if (rowNodeTransactions) {\n      rowNodeTransactions.forEach(tran => {\n        addNodesFunc(tran.add);\n        addNodesFunc(tran.update);\n        addNodesFunc(tran.remove);\n      });\n    }\n    return dirtyNodes;\n  }\n  doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {\n    const unsortedRows = rowNode.childrenAfterAggFilter;\n    const oldSortedRows = rowNode.childrenAfterSort;\n    if (!oldSortedRows) {\n      return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);\n    }\n    const untouchedRowsMap = {};\n    const touchedRows = [];\n    unsortedRows.forEach(row => {\n      if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) {\n        touchedRows.push(row);\n      } else {\n        untouchedRowsMap[row.id] = true;\n      }\n    });\n    const sortedUntouchedRows = oldSortedRows.filter(child => untouchedRowsMap[child.id]);\n    const mapNodeToSortedNode = (rowNode2, pos) => ({\n      currentPos: pos,\n      rowNode: rowNode2\n    });\n    const sortedChangedRows = touchedRows.map(mapNodeToSortedNode).sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));\n    return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(({\n      rowNode: rowNode2\n    }) => rowNode2);\n  }\n  // Merge two sorted arrays into each other\n  mergeSortedArrays(sortOptions, arr1, arr2) {\n    const res = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n      const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n      if (compareResult < 0) {\n        res.push(arr1[i++]);\n      } else {\n        res.push(arr2[j++]);\n      }\n    }\n    while (i < arr1.length) {\n      res.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n      res.push(arr2[j++]);\n    }\n    return res;\n  }\n  updateChildIndexes(rowNode) {\n    if (_missing2(rowNode.childrenAfterSort)) {\n      return;\n    }\n    const listToSort = rowNode.childrenAfterSort;\n    for (let i = 0; i < listToSort.length; i++) {\n      const child = listToSort[i];\n      const firstChild = i === 0;\n      const lastChild = i === rowNode.childrenAfterSort.length - 1;\n      child.setFirstChild(firstChild);\n      child.setLastChild(lastChild);\n      child.setChildIndex(i);\n    }\n  }\n  updateGroupDataForHideOpenParents(changedPath) {\n    if (!this.gos.get(\"groupHideOpenParents\")) {\n      return;\n    }\n    if (this.gos.get(\"treeData\")) {\n      _warnOnce3(`The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`);\n      return false;\n    }\n    const callback = rowNode => {\n      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n      rowNode.childrenAfterSort.forEach(child => {\n        if (child.hasChildren()) {\n          callback(child);\n        }\n      });\n    };\n    if (changedPath) {\n      changedPath.executeFromRootNode(rowNode => callback(rowNode));\n    }\n  }\n  pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {\n    if (!this.gos.get(\"groupHideOpenParents\") || _missing2(rowNodes)) {\n      return;\n    }\n    rowNodes.forEach(childRowNode => {\n      const groupDisplayCols = this.showRowGroupColsService?.getShowRowGroupCols() ?? [];\n      groupDisplayCols.forEach(groupDisplayCol => {\n        const showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n        if (typeof showRowGroup !== \"string\") {\n          _errorOnce4(\"groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup\");\n          return;\n        }\n        const displayingGroupKey = showRowGroup;\n        const rowGroupColumn = this.columnModel.getColDefCol(displayingGroupKey);\n        const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n        if (thisRowNodeMatches) {\n          return;\n        }\n        if (clearOperation) {\n          childRowNode.setGroupValue(groupDisplayCol.getId(), void 0);\n        } else {\n          const parentToStealFrom = this.getFirstChildOfFirstChild(childRowNode, rowGroupColumn);\n          if (parentToStealFrom) {\n            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n          }\n        }\n      });\n    });\n  }\n  getFirstChildOfFirstChild(node, rowGroupColumn) {\n    let currentRowNode = node;\n    while (currentRowNode) {\n      const parentRowNode = currentRowNode.parent;\n      if (parentRowNode && currentRowNode.firstChild) {\n        if (parentRowNode.rowGroupColumn === rowGroupColumn) {\n          return parentRowNode;\n        }\n      } else {\n        return null;\n      }\n      currentRowNode = parentRowNode;\n    }\n    return null;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/sortStage.ts\nimport { BeanStub as BeanStub6, _exists as _exists4, _isColumnsSortingCoupledToGroup } from \"@ag-grid-community/core\";\nvar SortStage = class extends BeanStub6 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sortStage\";\n  }\n  wireBeans(beans) {\n    this.sortService = beans.sortService;\n    this.sortController = beans.sortController;\n  }\n  execute(params) {\n    const sortOptions = this.sortController.getSortOptions();\n    const sortActive = _exists4(sortOptions) && sortOptions.length > 0;\n    const deltaSort = sortActive && _exists4(params.rowNodeTransactions) &&\n    // in time we can remove this check, so that delta sort is always\n    // on if transactions are present. it's off for now so that we can\n    // selectively turn it on and test it with some select users before\n    // rolling out to everyone.\n    this.gos.get(\"deltaSort\");\n    const sortContainsGroupColumns = sortOptions.some(opt => {\n      const isSortingCoupled = _isColumnsSortingCoupledToGroup(this.gos);\n      if (isSortingCoupled) {\n        return opt.column.isPrimary() && opt.column.isRowGroupActive();\n      }\n      return !!opt.column.getColDef().showRowGroup;\n    });\n    this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);\n  }\n};\n\n// community-modules/client-side-row-model/src/version.ts\nvar VERSION = \"32.3.3\";\n\n// community-modules/client-side-row-model/src/clientSideRowModelModule.ts\nvar ClientSideRowModelCoreModule = _defineModule({\n  version: VERSION,\n  moduleName: `${ModuleNames.ClientSideRowModelModule}-core`,\n  rowModel: \"clientSide\",\n  beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, ImmutableService]\n});\nvar ClientSideRowModelApiModule = _defineModule({\n  version: VERSION,\n  moduleName: `${ModuleNames.ClientSideRowModelModule}-api`,\n  beans: [RowModelHelperService],\n  apiFunctions: {\n    onGroupExpandedOrCollapsed,\n    refreshClientSideRowModel,\n    isRowDataEmpty,\n    forEachLeafNode,\n    forEachNodeAfterFilter,\n    forEachNodeAfterFilterAndSort,\n    resetRowHeights,\n    applyTransaction,\n    applyTransactionAsync,\n    flushAsyncTransactions,\n    getBestCostNodeSelection\n  },\n  dependantModules: [ClientSideRowModelCoreModule, _CsrmSsrmSharedApiModule]\n});\nvar ClientSideRowModelModule = _defineModule({\n  version: VERSION,\n  moduleName: ModuleNames.ClientSideRowModelModule,\n  dependantModules: [ClientSideRowModelCoreModule, ClientSideRowModelApiModule]\n});\nexport { ClientSideRowModelModule };","map":{"version":3,"names":["_defineModule","ModuleNames","RowModelHelperService","_CsrmSsrmSharedApiModule","BeanStub","ChangedPath","ClientSideRowModelSteps","RowHighlightPosition","RowNode","RowNode2","_debounce","_errorOnce","_errorOnce2","_exists","_getGrandTotalRow","_getGroupSelectsDescendants","_getGroupTotalRowCallback","_getRowHeightForNode","_insertIntoArray","_isAnimateRows","_isDomLayout","_last","_missing","_missingOrEmpty","_missingOrEmpty2","_removeFromArray","_cloneObject","_getRowIdCallback","_warnOnce","ROOT_NODE_ID","TOP_LEVEL","ClientSideNodeManager","constructor","rootNode","gos","eventService","funcColsService","selectionService","beans","nextId","rowCountReady","allNodesMap","group","level","id","allLeafChildren","childrenAfterGroup","childrenAfterSort","childrenAfterAggFilter","childrenAfterFilter","getCopyOfNodesMap","getRowNode","setRowData","rowData","dispatchRowDataUpdateStartedEvent","sibling","childrenMapped","updateHasChildren","map","dataItem","index","createNode","updateRowData","rowDataTran","add","updateRowDataResult","rowNodeTransaction","remove","update","rowsInserted","nodesToUnselect","executeRemove","executeUpdate","executeAdd","updateSelection","updateRowOrderFromRowData","rows","rowsLength","length","rowsOutOfOrder","Map","firstIndexOutOfOrder","lastIndexOutOfOrder","i","row","data","set","get","sourceRowIndex","isRowCountReady","dispatchEvent","type","firstRowData","source","selectionChanged","setNodesSelected","newValue","nodes","suppressFinishActions","updateGroupsFromChildrenSelections","result","addIndex","sanitizeAddIndex","isTreeData","node","rowIndex","newNodes","item","nodesBeforeIndex","slice","nodesAfterIndex","nodesAfterIndexFirstIndex","concat","allChildrenCount","Number","isNaN","Math","ceil","rowIdsRemoved","forEach","rowNode","lookupRowNode","isSelected","push","clearRowTopAndRowIndex","filter","idx","updateData","selectable","setMasterForRow","getRowIdFunc","find","parent","setDataAndId","toString","setExpanded","setMaster","expanded","masterDetail","isRowMasterFunc","rowGroupColumns","getRowGroupColumns","numRowGroupColumns","masterRowLevel","master","isExpanded","expandByDefault","ClientSideRowModel","arguments","beanName","onRowHeightChanged_debounced","onRowHeightChanged","bind","rowsToDisplay","hasStarted","shouldSkipSettingDataOnStart","isRefreshingModel","wireBeans","columnModel","valueCache","environment","filterStage","sortStage","flattenStage","groupStage","aggregationStage","pivotStage","filterAggregatesStage","postConstruct","refreshEverythingFunc","refreshModel","step","EVERYTHING","animate","refreshEverythingAfterColsChangedFunc","afterColumnsChanged","keepRenderedRows","addManagedEventListeners","newColumnsLoaded","columnRowGroupChanged","columnValueChanged","onValueChanged","columnPivotChanged","PIVOT","filterChanged","onFilterChanged","sortChanged","onSortChanged","columnPivotModeChanged","gridStylesChanged","onGridStylesChanges","gridReady","onGridReady","addPropertyListeners","nodeManager","resetProps","Set","groupStageRefreshProps","filterStageRefreshProps","pivotStageRefreshProps","aggregateStageRefreshProps","sortStageRefreshProps","filterAggStageRefreshProps","flattenStageRefreshProps","allProps","addManagedPropertyListeners","params","properties","changeSet","arePropertiesImpacted","propSet","some","prop","has","child","FILTER","AGGREGATE","SORT","FILTER_AGGREGATES","MAP","addManagedPropertyListener","resetRowHeights","start","dispatchUpdateEventsAndRefresh","setInitialData","ensureRowHeightsValid","startPixel","endPixel","startLimitIndex","endLimitIndex","atLeastOneChange","res","rowAtStartPixel","getRowIndexAtPixel","rowAtEndPixel","firstRow","max","lastRow","min","getRow","rowHeightEstimated","rowHeight","setRowHeight","height","setRowTopAndRowIndex","defaultRowHeight","getDefaultRowHeight","nextRowTop","displayedRowsMapped","allowEstimate","estimated","setRowTop","setRowIndex","changedPath","changedPathActive","isActive","clearIfNotDisplayed","recurse","detailNode","hasChildren","isRootNode","skipChildren","ensureRowsAtPixel","rowNodes","pixel","increment","indexAtPixelNow","rowNodeAtPixelNow","keepEditingRows","rowNodesOrderChanged","highlightRowAtPixel","clearHighlightedRow","highlight","getHighlightPosition","isSamePosition","isHighlightingCurrentPosition","isDifferentNode","lastHighlightedRow","setHighlighted","Below","rowTop","Above","getLastHighlightedRowNode","movingRowNode","hoveredRowNode","highlightPosition","diff","isLastRowIndexKnown","getRowCount","getTopLevelRowCount","showingRootNode","filteredChildren","totalFooterInc","getTopLevelRowDisplayedIndex","topLevelIndex","adjustedIndex","footer","indexOutsideGroupBounds","getRowBounds","onRowGroupOpened","event","afterDataChange","primaryOrQuickFilterChanged","columns","col","isPrimary","getType","isPivotActive","createChangePath","rowNodeTransactions","noTransactions","setInactive","isSuppressModelUpdateAfterUpdateTransaction","transWithAddsOrDeletes","tx","transactionsContainUpdatesOnly","buildRefreshModelParams","paramsStep","stepsMapped","everything","aggregate","filter_aggregates","sort","pivot","nothing","NOTHING","Object","keys","join","modelParams","paramsOrStep","isChangeEventsDispatching","doRowGrouping","doFilter","doPivot","doAggregate","doFilterAggregates","doSort","doRowsToDisplay","displayedNodesMapped","newData","newPage","keepUndoRedoStack","isEmpty","rowsMissing","isReady","isRowsToRender","getNodesInRangeForSelection","firstInRange","lastInRange","started","finished","groupsSelectChildren","forEachNodeAfterFilterAndSort","includeThisNode","setDatasource","datasource","getTopLevelNodes","getRootNode","isRowPresent","indexOf","pixelToMatch","bottomPointer","topPointer","lastNode","oldBottomPointer","oldTopPointer","midPointer","floor","currentRowNode","isRowInPixel","caughtInInfiniteLoop","topPixel","bottomPixel","pixelInRow","forEachLeafNode","callback","forEachNode","includeFooterNodes","recursivelyWalkNodesAndCallback","recursionType","forEachNodeAfterFilter","forEachPivotNode","addFooters","position","parentNode","grandTotal","isGroupIncludeFooter","groupTotal","createFooter","nodeChildren","leafGroup","execute","expandOrCollapseAll","expand","usingTreeData","usingPivotMode","recursiveExpandOrCollapse","actionRow","notLeafGroup","isRowGroup","dispatchEventOnce","getNodeManager","idIsGroup","ID_PREFIX_ROW_GROUP","reset","batchUpdateRowData","rowDataTransaction","applyAsyncTransactionsTimeout","rowDataTransactionBatch","waitMillis","window","setTimeout","isAlive","executeBatchUpdateRowData","flushAsyncTransactions","clearTimeout","onDataChanged","callbackFuncsBound","rowNodeTrans","orderChanged","tranItem","commonUpdateRowData","func","results","afterImmutableDataChange","onRowHeightChangedDebounced","atLeastOne","resetRowHeightsForAllRowNodes","e","rowHeightChanged","isAutoRowHeightActive","isRowDataLoaded","destroy","_warnOnce2","onGroupExpandedOrCollapsed","expansionService","refreshClientSideRowModel","rowModelHelperService","getClientSideRowModel","isRowDataEmpty","applyTransaction","frameworkOverrides","wrapIncoming","applyTransactionAsync","getBestCostNodeSelection","BeanStub2","FilterStage","filterManager","filterActive","isChildFilterPresent","filterNodes","filterCallback","includeChildNodes","childNode","passBecauseChildren","passBecauseDataPasses","doesRowPassFilter","doingTreeDataFiltering","treeDataDepthFirstFilter","alreadyFoundInParent","foundInParent","treeDataFilterCallback","executeFromRootNode","defaultFilterCallback","forEachChangedNodeDepthFirst","BeanStub3","RowNode3","_exists2","_getGrandTotalRow2","_getGroupTotalRowCallback2","_isGroupMultiAutoColumn","_missingOrEmpty3","FlattenStage","skipLeafNodes","isPivotMode","showRootNode","topList","details","getFlattenDetails","recursivelyAddToRowsToDisplay","atLeastOneRowPresent","includeGrandTotalRow","grandTotalRow","addToTop","addRowNodeToRowsToDisplay","groupRemoveSingleChildren","groupRemoveLowestSingleChildren","isGroupMultiAutoColumn","hideOpenParents","groupTotalRow","rowsToFlatten","uiLevel","isParent","isSkippedLeafNode","isRemovedSingleChildrenGroup","isRemovedLowestSingleChildrenGroup","neverAllowToExpand","isHiddenOpenParent","thisRowShouldBeRendered","excludedParent","doesRowShowFooter","destroyFooter","uiLevelForChildren","createDetailNode","unshift","setUiLevel","masterNode","detail","BeanStub4","_errorOnce3","_exists3","_getRowIdCallback2","_isClientSideRowModel","_iterateObject","ImmutableService","rowModel","clientSideRowModel","onRowDataUpdated","getRowIdProvided","exists","resetRowDataOnUpdate","createTransactionForRowData","suppressSortOrder","existingNodesMap","existingNode","dataHasChanged","BeanStub5","_errorOnce4","_missing2","_warnOnce3","SortService","rowNodeSorter","showRowGroupColsService","sortOptions","sortActive","useDeltaSort","sortContainsGroupColumns","groupMaintainOrder","groupColumnsPresent","getCols","c","isRowGroupActive","allDirtyNodes","calculateDirtyNodes","postSortFunc","getCallback","pullDownGroupDataForHideOpenParents","skipSortingPivotLeafs","skipSortingGroups","nextGroup","wasSortExplicitlyRemoved","getSort","childrenToBeSorted","indexedOrders","row1","row2","doDeltaSort","doFullSort","updateChildIndexes","updateGroupDataForHideOpenParents","dirtyNodes","addNodesFunc","tran","allTouchedNodes","unsortedRows","oldSortedRows","untouchedRowsMap","touchedRows","canSkip","sortedUntouchedRows","mapNodeToSortedNode","rowNode2","pos","currentPos","sortedChangedRows","a","b","compareRowNodes","mergeSortedArrays","arr1","arr2","j","compareResult","listToSort","firstChild","lastChild","setFirstChild","setLastChild","setChildIndex","clearOperation","childRowNode","groupDisplayCols","getShowRowGroupCols","groupDisplayCol","showRowGroup","getColDef","displayingGroupKey","rowGroupColumn","getColDefCol","thisRowNodeMatches","setGroupValue","getId","parentToStealFrom","getFirstChildOfFirstChild","key","parentRowNode","BeanStub6","_exists4","_isColumnsSortingCoupledToGroup","SortStage","sortService","sortController","getSortOptions","deltaSort","opt","isSortingCoupled","column","VERSION","ClientSideRowModelCoreModule","version","moduleName","ClientSideRowModelModule","ClientSideRowModelApiModule","apiFunctions","dependantModules"],"sources":["/Users/nicktorrens/Documents/Grad Cert in Web Development 2024/Portfolio Applications/The Good Weekend Quiz/node_modules/@ag-grid-community/client-side-row-model/dist/package/main.esm.mjs"],"sourcesContent":["// community-modules/client-side-row-model/src/clientSideRowModelModule.ts\nimport { _defineModule } from \"@ag-grid-community/core\";\nimport { ModuleNames, RowModelHelperService, _CsrmSsrmSharedApiModule } from \"@ag-grid-community/core\";\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModel.ts\nimport {\n  BeanStub,\n  ChangedPath,\n  ClientSideRowModelSteps,\n  RowHighlightPosition,\n  RowNode as RowNode2,\n  _debounce,\n  _errorOnce as _errorOnce2,\n  _exists,\n  _getGrandTotalRow,\n  _getGroupSelectsDescendants,\n  _getGroupTotalRowCallback,\n  _getRowHeightForNode,\n  _insertIntoArray,\n  _isAnimateRows,\n  _isDomLayout,\n  _last,\n  _missing,\n  _missingOrEmpty as _missingOrEmpty2,\n  _removeFromArray\n} from \"@ag-grid-community/core\";\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideNodeManager.ts\nimport {\n  RowNode,\n  _cloneObject,\n  _errorOnce,\n  _getRowIdCallback,\n  _missingOrEmpty,\n  _warnOnce\n} from \"@ag-grid-community/core\";\nvar ROOT_NODE_ID = \"ROOT_NODE_ID\";\nvar TOP_LEVEL = 0;\nvar ClientSideNodeManager = class {\n  constructor(rootNode, gos, eventService, funcColsService, selectionService, beans) {\n    this.nextId = 0;\n    // has row data actually been set\n    this.rowCountReady = false;\n    // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n    this.allNodesMap = {};\n    this.rootNode = rootNode;\n    this.gos = gos;\n    this.eventService = eventService;\n    this.funcColsService = funcColsService;\n    this.beans = beans;\n    this.selectionService = selectionService;\n    this.rootNode.group = true;\n    this.rootNode.level = -1;\n    this.rootNode.id = ROOT_NODE_ID;\n    this.rootNode.allLeafChildren = [];\n    this.rootNode.childrenAfterGroup = [];\n    this.rootNode.childrenAfterSort = [];\n    this.rootNode.childrenAfterAggFilter = [];\n    this.rootNode.childrenAfterFilter = [];\n  }\n  getCopyOfNodesMap() {\n    return _cloneObject(this.allNodesMap);\n  }\n  getRowNode(id) {\n    return this.allNodesMap[id];\n  }\n  setRowData(rowData) {\n    if (typeof rowData === \"string\") {\n      _warnOnce(\"rowData must be an array.\");\n      return;\n    }\n    this.rowCountReady = true;\n    this.dispatchRowDataUpdateStartedEvent(rowData);\n    const rootNode = this.rootNode;\n    const sibling = this.rootNode.sibling;\n    rootNode.childrenAfterFilter = null;\n    rootNode.childrenAfterGroup = null;\n    rootNode.childrenAfterAggFilter = null;\n    rootNode.childrenAfterSort = null;\n    rootNode.childrenMapped = null;\n    rootNode.updateHasChildren();\n    this.nextId = 0;\n    this.allNodesMap = {};\n    if (rowData) {\n      rootNode.allLeafChildren = rowData.map(\n        (dataItem, index) => this.createNode(dataItem, this.rootNode, TOP_LEVEL, index)\n      );\n    } else {\n      rootNode.allLeafChildren = [];\n      rootNode.childrenAfterGroup = [];\n    }\n    if (sibling) {\n      sibling.childrenAfterFilter = rootNode.childrenAfterFilter;\n      sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n      sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;\n      sibling.childrenAfterSort = rootNode.childrenAfterSort;\n      sibling.childrenMapped = rootNode.childrenMapped;\n      sibling.allLeafChildren = rootNode.allLeafChildren;\n    }\n  }\n  updateRowData(rowDataTran) {\n    this.rowCountReady = true;\n    this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);\n    const updateRowDataResult = {\n      rowNodeTransaction: { remove: [], update: [], add: [] },\n      rowsInserted: false\n    };\n    const nodesToUnselect = [];\n    this.executeRemove(rowDataTran, updateRowDataResult, nodesToUnselect);\n    this.executeUpdate(rowDataTran, updateRowDataResult, nodesToUnselect);\n    this.executeAdd(rowDataTran, updateRowDataResult);\n    this.updateSelection(nodesToUnselect, \"rowDataChanged\");\n    return updateRowDataResult;\n  }\n  /**\n   * Used by the immutable service, after updateRowData, after updating with a generated transaction to\n   * apply the order as specified by the the new data. We use sourceRowIndex to determine the order of the rows.\n   * Time complexity is O(n) where n is the number of rows/rowData\n   * @returns true if the order changed, otherwise false\n   */\n  updateRowOrderFromRowData(rowData) {\n    const rows = this.rootNode.allLeafChildren;\n    const rowsLength = rows?.length ?? 0;\n    const rowsOutOfOrder = /* @__PURE__ */ new Map();\n    let firstIndexOutOfOrder = -1;\n    let lastIndexOutOfOrder = -1;\n    for (let i = 0; i < rowsLength; ++i) {\n      const row = rows[i];\n      const data = row.data;\n      if (data !== rowData[i]) {\n        if (lastIndexOutOfOrder < 0) {\n          firstIndexOutOfOrder = i;\n        }\n        lastIndexOutOfOrder = i;\n        rowsOutOfOrder.set(data, row);\n      }\n    }\n    if (firstIndexOutOfOrder < 0) {\n      return false;\n    }\n    for (let i = firstIndexOutOfOrder; i <= lastIndexOutOfOrder; ++i) {\n      const row = rowsOutOfOrder.get(rowData[i]);\n      if (row !== void 0) {\n        rows[i] = row;\n        row.sourceRowIndex = i;\n      }\n    }\n    return true;\n  }\n  isRowCountReady() {\n    return this.rowCountReady;\n  }\n  dispatchRowDataUpdateStartedEvent(rowData) {\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdateStarted\",\n      firstRowData: rowData?.length ? rowData[0] : null\n    });\n  }\n  updateSelection(nodesToUnselect, source) {\n    const selectionChanged = nodesToUnselect.length > 0;\n    if (selectionChanged) {\n      this.selectionService.setNodesSelected({\n        newValue: false,\n        nodes: nodesToUnselect,\n        suppressFinishActions: true,\n        source\n      });\n    }\n    this.selectionService.updateGroupsFromChildrenSelections(source);\n    if (selectionChanged) {\n      this.eventService.dispatchEvent({\n        type: \"selectionChanged\",\n        source\n      });\n    }\n  }\n  executeAdd(rowDataTran, result) {\n    const add = rowDataTran.add;\n    if (_missingOrEmpty(add)) {\n      return;\n    }\n    const allLeafChildren = this.rootNode.allLeafChildren;\n    let addIndex = allLeafChildren.length;\n    if (typeof rowDataTran.addIndex === \"number\") {\n      addIndex = this.sanitizeAddIndex(rowDataTran.addIndex);\n      if (addIndex > 0) {\n        const isTreeData = this.gos.get(\"treeData\");\n        if (isTreeData) {\n          for (let i = 0; i < allLeafChildren.length; i++) {\n            const node = allLeafChildren[i];\n            if (node?.rowIndex == addIndex - 1) {\n              addIndex = i + 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    const newNodes = add.map(\n      (item, index) => this.createNode(item, this.rootNode, TOP_LEVEL, addIndex + index)\n    );\n    if (addIndex < allLeafChildren.length) {\n      const nodesBeforeIndex = allLeafChildren.slice(0, addIndex);\n      const nodesAfterIndex = allLeafChildren.slice(addIndex, allLeafChildren.length);\n      const nodesAfterIndexFirstIndex = nodesBeforeIndex.length + newNodes.length;\n      for (let index = 0, length = nodesAfterIndex.length; index < length; ++index) {\n        nodesAfterIndex[index].sourceRowIndex = nodesAfterIndexFirstIndex + index;\n      }\n      this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];\n      result.rowsInserted = true;\n    } else {\n      this.rootNode.allLeafChildren = allLeafChildren.concat(newNodes);\n    }\n    const sibling = this.rootNode.sibling;\n    if (sibling) {\n      sibling.allLeafChildren = allLeafChildren;\n    }\n    result.rowNodeTransaction.add = newNodes;\n  }\n  sanitizeAddIndex(addIndex) {\n    const allChildrenCount = this.rootNode.allLeafChildren?.length ?? 0;\n    if (addIndex < 0 || addIndex >= allChildrenCount || Number.isNaN(addIndex)) {\n      return allChildrenCount;\n    }\n    return Math.ceil(addIndex);\n  }\n  executeRemove(rowDataTran, { rowNodeTransaction }, nodesToUnselect) {\n    const { remove } = rowDataTran;\n    if (_missingOrEmpty(remove)) {\n      return;\n    }\n    const rowIdsRemoved = {};\n    remove.forEach((item) => {\n      const rowNode = this.lookupRowNode(item);\n      if (!rowNode) {\n        return;\n      }\n      if (rowNode.isSelected()) {\n        nodesToUnselect.push(rowNode);\n      }\n      rowNode.clearRowTopAndRowIndex();\n      rowIdsRemoved[rowNode.id] = true;\n      delete this.allNodesMap[rowNode.id];\n      rowNodeTransaction.remove.push(rowNode);\n    });\n    this.rootNode.allLeafChildren = this.rootNode.allLeafChildren?.filter((rowNode) => !rowIdsRemoved[rowNode.id]) ?? null;\n    this.rootNode.allLeafChildren?.forEach((node, idx) => {\n      node.sourceRowIndex = idx;\n    });\n    const sibling = this.rootNode.sibling;\n    if (sibling) {\n      sibling.allLeafChildren = this.rootNode.allLeafChildren;\n    }\n  }\n  executeUpdate(rowDataTran, { rowNodeTransaction }, nodesToUnselect) {\n    const { update } = rowDataTran;\n    if (_missingOrEmpty(update)) {\n      return;\n    }\n    update.forEach((item) => {\n      const rowNode = this.lookupRowNode(item);\n      if (!rowNode) {\n        return;\n      }\n      rowNode.updateData(item);\n      if (!rowNode.selectable && rowNode.isSelected()) {\n        nodesToUnselect.push(rowNode);\n      }\n      this.setMasterForRow(rowNode, item, TOP_LEVEL, false);\n      rowNodeTransaction.update.push(rowNode);\n    });\n  }\n  lookupRowNode(data) {\n    const getRowIdFunc = _getRowIdCallback(this.gos);\n    let rowNode;\n    if (getRowIdFunc) {\n      const id = getRowIdFunc({ data, level: 0 });\n      rowNode = this.allNodesMap[id];\n      if (!rowNode) {\n        _errorOnce(`could not find row id=${id}, data item was not found for this id`);\n        return null;\n      }\n    } else {\n      rowNode = this.rootNode.allLeafChildren?.find((node) => node.data === data);\n      if (!rowNode) {\n        _errorOnce(`could not find data item as object was not found`, data);\n        _errorOnce(`Consider using getRowId to help the Grid find matching row data`);\n        return null;\n      }\n    }\n    return rowNode || null;\n  }\n  createNode(dataItem, parent, level, sourceRowIndex) {\n    const node = new RowNode(this.beans);\n    node.sourceRowIndex = sourceRowIndex;\n    node.group = false;\n    this.setMasterForRow(node, dataItem, level, true);\n    if (parent) {\n      node.parent = parent;\n    }\n    node.level = level;\n    node.setDataAndId(dataItem, this.nextId.toString());\n    if (this.allNodesMap[node.id]) {\n      _warnOnce(\n        `duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`\n      );\n    }\n    this.allNodesMap[node.id] = node;\n    this.nextId++;\n    return node;\n  }\n  setMasterForRow(rowNode, data, level, setExpanded) {\n    const isTreeData = this.gos.get(\"treeData\");\n    if (isTreeData) {\n      rowNode.setMaster(false);\n      if (setExpanded) {\n        rowNode.expanded = false;\n      }\n    } else {\n      const masterDetail = this.gos.get(\"masterDetail\");\n      if (masterDetail) {\n        const isRowMasterFunc = this.gos.get(\"isRowMaster\");\n        if (isRowMasterFunc) {\n          rowNode.setMaster(isRowMasterFunc(data));\n        } else {\n          rowNode.setMaster(true);\n        }\n      } else {\n        rowNode.setMaster(false);\n      }\n      if (setExpanded) {\n        const rowGroupColumns = this.funcColsService.getRowGroupColumns();\n        const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\n        const masterRowLevel = level + numRowGroupColumns;\n        rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;\n      }\n    }\n  }\n  isExpanded(level) {\n    const expandByDefault = this.gos.get(\"groupDefaultExpanded\");\n    if (expandByDefault === -1) {\n      return true;\n    }\n    return level < expandByDefault;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModel.ts\nvar ClientSideRowModel = class extends BeanStub {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"rowModel\";\n    this.onRowHeightChanged_debounced = _debounce(this.onRowHeightChanged.bind(this), 100);\n    this.rowsToDisplay = [];\n    /** Has the start method been called */\n    this.hasStarted = false;\n    /** E.g. data has been set into the node manager already */\n    this.shouldSkipSettingDataOnStart = false;\n    /**\n     * This is to prevent refresh model being called when it's already being called.\n     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,\n     * which then triggers the listener here that calls refresh model again but at the filter stage\n     * (which is about to be run by the original call).\n     */\n    this.isRefreshingModel = false;\n    this.rowCountReady = false;\n  }\n  wireBeans(beans) {\n    this.beans = beans;\n    this.columnModel = beans.columnModel;\n    this.funcColsService = beans.funcColsService;\n    this.selectionService = beans.selectionService;\n    this.valueCache = beans.valueCache;\n    this.environment = beans.environment;\n    this.filterStage = beans.filterStage;\n    this.sortStage = beans.sortStage;\n    this.flattenStage = beans.flattenStage;\n    this.groupStage = beans.groupStage;\n    this.aggregationStage = beans.aggregationStage;\n    this.pivotStage = beans.pivotStage;\n    this.filterAggregatesStage = beans.filterAggregatesStage;\n  }\n  postConstruct() {\n    const refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING,\n      // after cols change, row grouping (the first stage) could of changed\n      afterColumnsChanged: true,\n      keepRenderedRows: true,\n      // we want animations cos sorting or filtering could be applied\n      animate\n    });\n    this.addManagedEventListeners({\n      newColumnsLoaded: refreshEverythingAfterColsChangedFunc,\n      columnRowGroupChanged: refreshEverythingFunc,\n      columnValueChanged: this.onValueChanged.bind(this),\n      columnPivotChanged: this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }),\n      filterChanged: this.onFilterChanged.bind(this),\n      sortChanged: this.onSortChanged.bind(this),\n      columnPivotModeChanged: refreshEverythingFunc,\n      gridStylesChanged: this.onGridStylesChanges.bind(this),\n      gridReady: this.onGridReady.bind(this)\n    });\n    this.addPropertyListeners();\n    this.rootNode = new RowNode2(this.beans);\n    this.nodeManager = new ClientSideNodeManager(\n      this.rootNode,\n      this.gos,\n      this.eventService,\n      this.funcColsService,\n      this.selectionService,\n      this.beans\n    );\n  }\n  addPropertyListeners() {\n    const resetProps = /* @__PURE__ */ new Set([\"treeData\", \"masterDetail\"]);\n    const groupStageRefreshProps = /* @__PURE__ */ new Set([\n      \"groupDefaultExpanded\",\n      \"groupAllowUnbalanced\",\n      \"initialGroupOrderComparator\",\n      \"groupHideOpenParents\",\n      \"groupDisplayType\"\n    ]);\n    const filterStageRefreshProps = /* @__PURE__ */ new Set([\"excludeChildrenWhenTreeDataFiltering\"]);\n    const pivotStageRefreshProps = /* @__PURE__ */ new Set([\n      \"removePivotHeaderRowWhenSingleValueColumn\",\n      \"pivotRowTotals\",\n      \"pivotColumnGroupTotals\",\n      \"suppressExpandablePivotGroups\"\n    ]);\n    const aggregateStageRefreshProps = /* @__PURE__ */ new Set([\n      \"getGroupRowAgg\",\n      \"alwaysAggregateAtRootLevel\",\n      \"groupIncludeTotalFooter\",\n      \"suppressAggFilteredOnly\",\n      \"grandTotalRow\"\n    ]);\n    const sortStageRefreshProps = /* @__PURE__ */ new Set([\n      \"postSortRows\",\n      \"groupDisplayType\",\n      \"accentedSort\"\n    ]);\n    const filterAggStageRefreshProps = /* @__PURE__ */ new Set([]);\n    const flattenStageRefreshProps = /* @__PURE__ */ new Set([\n      \"groupRemoveSingleChildren\",\n      \"groupRemoveLowestSingleChildren\",\n      \"groupIncludeFooter\",\n      \"groupTotalRow\"\n    ]);\n    const allProps = [\n      ...resetProps,\n      ...groupStageRefreshProps,\n      ...filterStageRefreshProps,\n      ...pivotStageRefreshProps,\n      ...pivotStageRefreshProps,\n      ...aggregateStageRefreshProps,\n      ...sortStageRefreshProps,\n      ...filterAggStageRefreshProps,\n      ...flattenStageRefreshProps\n    ];\n    this.addManagedPropertyListeners(allProps, (params) => {\n      const properties = params.changeSet?.properties;\n      if (!properties) {\n        return;\n      }\n      const arePropertiesImpacted = (propSet) => properties.some((prop) => propSet.has(prop));\n      if (arePropertiesImpacted(resetProps)) {\n        this.setRowData(this.rootNode.allLeafChildren.map((child) => child.data));\n        return;\n      }\n      if (arePropertiesImpacted(groupStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.EVERYTHING });\n        return;\n      }\n      if (arePropertiesImpacted(filterStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.FILTER });\n        return;\n      }\n      if (arePropertiesImpacted(pivotStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        return;\n      }\n      if (arePropertiesImpacted(aggregateStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        return;\n      }\n      if (arePropertiesImpacted(sortStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.SORT });\n        return;\n      }\n      if (arePropertiesImpacted(filterAggStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.FILTER_AGGREGATES });\n        return;\n      }\n      if (arePropertiesImpacted(flattenStageRefreshProps)) {\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n      }\n    });\n    this.addManagedPropertyListener(\"rowHeight\", () => this.resetRowHeights());\n  }\n  start() {\n    this.hasStarted = true;\n    if (this.shouldSkipSettingDataOnStart) {\n      this.dispatchUpdateEventsAndRefresh();\n    } else {\n      this.setInitialData();\n    }\n  }\n  setInitialData() {\n    const rowData = this.gos.get(\"rowData\");\n    if (rowData) {\n      this.shouldSkipSettingDataOnStart = true;\n      this.setRowData(rowData);\n    }\n  }\n  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    let atLeastOneChange;\n    let res = false;\n    do {\n      atLeastOneChange = false;\n      const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n      const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n      const firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n      const lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n      for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n        const rowNode = this.getRow(rowIndex);\n        if (rowNode.rowHeightEstimated) {\n          const rowHeight = _getRowHeightForNode(this.gos, rowNode);\n          rowNode.setRowHeight(rowHeight.height);\n          atLeastOneChange = true;\n          res = true;\n        }\n      }\n      if (atLeastOneChange) {\n        this.setRowTopAndRowIndex();\n      }\n    } while (atLeastOneChange);\n    return res;\n  }\n  setRowTopAndRowIndex() {\n    const defaultRowHeight = this.environment.getDefaultRowHeight();\n    let nextRowTop = 0;\n    const displayedRowsMapped = /* @__PURE__ */ new Set();\n    const allowEstimate = _isDomLayout(this.gos, \"normal\");\n    for (let i = 0; i < this.rowsToDisplay.length; i++) {\n      const rowNode = this.rowsToDisplay[i];\n      if (rowNode.id != null) {\n        displayedRowsMapped.add(rowNode.id);\n      }\n      if (rowNode.rowHeight == null) {\n        const rowHeight = _getRowHeightForNode(this.gos, rowNode, allowEstimate, defaultRowHeight);\n        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n      }\n      rowNode.setRowTop(nextRowTop);\n      rowNode.setRowIndex(i);\n      nextRowTop += rowNode.rowHeight;\n    }\n    return displayedRowsMapped;\n  }\n  clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {\n    const changedPathActive = changedPath.isActive();\n    const clearIfNotDisplayed = (rowNode) => {\n      if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n        rowNode.clearRowTopAndRowIndex();\n      }\n    };\n    const recurse = (rowNode) => {\n      clearIfNotDisplayed(rowNode);\n      clearIfNotDisplayed(rowNode.detailNode);\n      clearIfNotDisplayed(rowNode.sibling);\n      if (rowNode.hasChildren()) {\n        if (rowNode.childrenAfterGroup) {\n          const isRootNode = rowNode.level == -1;\n          const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n          if (!skipChildren) {\n            rowNode.childrenAfterGroup.forEach(recurse);\n          }\n        }\n      }\n    };\n    recurse(this.rootNode);\n  }\n  // returns false if row was moved, otherwise true\n  ensureRowsAtPixel(rowNodes, pixel, increment = 0) {\n    const indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n    const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    if (rowNodeAtPixelNow === rowNodes[0]) {\n      return false;\n    }\n    const allLeafChildren = this.rootNode.allLeafChildren;\n    rowNodes.forEach((rowNode) => {\n      _removeFromArray(allLeafChildren, rowNode);\n    });\n    rowNodes.forEach((rowNode, idx) => {\n      _insertIntoArray(allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n    });\n    rowNodes.forEach((rowNode, index) => {\n      rowNode.sourceRowIndex = index;\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate,\n      rowNodesOrderChanged: true\n      // We assume the order changed and we don't need to check if it really did\n    });\n    return true;\n  }\n  highlightRowAtPixel(rowNode, pixel) {\n    const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n    const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n    if (!rowNodeAtPixelNow || !rowNode || pixel == null) {\n      this.clearHighlightedRow();\n      return;\n    }\n    const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n    const isSamePosition = this.isHighlightingCurrentPosition(rowNode, rowNodeAtPixelNow, highlight);\n    const isDifferentNode = this.lastHighlightedRow != null && this.lastHighlightedRow !== rowNodeAtPixelNow;\n    if (isSamePosition || isDifferentNode) {\n      this.clearHighlightedRow();\n      if (isSamePosition) {\n        return;\n      }\n    }\n    rowNodeAtPixelNow.setHighlighted(highlight);\n    this.lastHighlightedRow = rowNodeAtPixelNow;\n  }\n  getHighlightPosition(pixel, rowNode) {\n    if (!rowNode) {\n      const index = this.getRowIndexAtPixel(pixel);\n      rowNode = this.getRow(index || 0);\n      if (!rowNode) {\n        return RowHighlightPosition.Below;\n      }\n    }\n    const { rowTop, rowHeight } = rowNode;\n    return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n  }\n  getLastHighlightedRowNode() {\n    return this.lastHighlightedRow;\n  }\n  isHighlightingCurrentPosition(movingRowNode, hoveredRowNode, highlightPosition) {\n    if (movingRowNode === hoveredRowNode) {\n      return true;\n    }\n    const diff = highlightPosition === RowHighlightPosition.Above ? -1 : 1;\n    if (this.getRow(hoveredRowNode.rowIndex + diff) === movingRowNode) {\n      return true;\n    }\n    return false;\n  }\n  clearHighlightedRow() {\n    if (this.lastHighlightedRow) {\n      this.lastHighlightedRow.setHighlighted(null);\n      this.lastHighlightedRow = null;\n    }\n  }\n  isLastRowIndexKnown() {\n    return true;\n  }\n  getRowCount() {\n    if (this.rowsToDisplay) {\n      return this.rowsToDisplay.length;\n    }\n    return 0;\n  }\n  /**\n   * Returns the number of rows with level === 1\n   */\n  getTopLevelRowCount() {\n    if (this.rowsToDisplay.length === 0) {\n      return 0;\n    }\n    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n    if (showingRootNode) {\n      return 1;\n    }\n    const filteredChildren = this.rootNode.childrenAfterAggFilter;\n    const totalFooterInc = this.rootNode.sibling ? 1 : 0;\n    return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;\n  }\n  /**\n   * Get the row display index by the top level index\n   * top level index is the index of rows with level === 1\n   */\n  getTopLevelRowDisplayedIndex(topLevelIndex) {\n    const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n    if (showingRootNode) {\n      return topLevelIndex;\n    }\n    let adjustedIndex = topLevelIndex;\n    if (this.rowsToDisplay[0].footer) {\n      if (topLevelIndex === 0) {\n        return 0;\n      }\n      adjustedIndex -= 1;\n    }\n    const lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];\n    const indexOutsideGroupBounds = adjustedIndex >= this.rootNode.childrenAfterSort.length;\n    if (lastRow.footer && indexOutsideGroupBounds) {\n      return lastRow.rowIndex;\n    }\n    let rowNode = this.rootNode.childrenAfterSort[adjustedIndex];\n    if (this.gos.get(\"groupHideOpenParents\")) {\n      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n        rowNode = rowNode.childrenAfterSort[0];\n      }\n    }\n    return rowNode.rowIndex;\n  }\n  getRowBounds(index) {\n    if (_missing(this.rowsToDisplay)) {\n      return null;\n    }\n    const rowNode = this.rowsToDisplay[index];\n    if (rowNode) {\n      return {\n        rowTop: rowNode.rowTop,\n        rowHeight: rowNode.rowHeight\n      };\n    }\n    return null;\n  }\n  onRowGroupOpened() {\n    const animate = _isAnimateRows(this.gos);\n    this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate });\n  }\n  onFilterChanged(event) {\n    if (event.afterDataChange) {\n      return;\n    }\n    const animate = _isAnimateRows(this.gos);\n    const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());\n    const step = primaryOrQuickFilterChanged ? ClientSideRowModelSteps.FILTER : ClientSideRowModelSteps.FILTER_AGGREGATES;\n    this.refreshModel({ step, keepRenderedRows: true, animate });\n  }\n  onSortChanged() {\n    const animate = _isAnimateRows(this.gos);\n    this.refreshModel({\n      step: ClientSideRowModelSteps.SORT,\n      keepRenderedRows: true,\n      animate,\n      keepEditingRows: true\n    });\n  }\n  getType() {\n    return \"clientSide\";\n  }\n  onValueChanged() {\n    if (this.columnModel.isPivotActive()) {\n      this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n    } else {\n      this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n    }\n  }\n  createChangePath(rowNodeTransactions) {\n    const noTransactions = _missingOrEmpty2(rowNodeTransactions);\n    const changedPath = new ChangedPath(false, this.rootNode);\n    if (noTransactions) {\n      changedPath.setInactive();\n    }\n    return changedPath;\n  }\n  isSuppressModelUpdateAfterUpdateTransaction(params) {\n    if (!this.gos.get(\"suppressModelUpdateAfterUpdateTransaction\")) {\n      return false;\n    }\n    if (params.rowNodeTransactions == null) {\n      return false;\n    }\n    const transWithAddsOrDeletes = params.rowNodeTransactions.filter(\n      (tx) => tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0\n    );\n    const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n    return transactionsContainUpdatesOnly;\n  }\n  buildRefreshModelParams(step) {\n    let paramsStep = ClientSideRowModelSteps.EVERYTHING;\n    const stepsMapped = {\n      everything: ClientSideRowModelSteps.EVERYTHING,\n      group: ClientSideRowModelSteps.EVERYTHING,\n      filter: ClientSideRowModelSteps.FILTER,\n      map: ClientSideRowModelSteps.MAP,\n      aggregate: ClientSideRowModelSteps.AGGREGATE,\n      filter_aggregates: ClientSideRowModelSteps.FILTER_AGGREGATES,\n      sort: ClientSideRowModelSteps.SORT,\n      pivot: ClientSideRowModelSteps.PIVOT,\n      nothing: ClientSideRowModelSteps.NOTHING\n    };\n    if (_exists(step)) {\n      paramsStep = stepsMapped[step];\n    }\n    if (_missing(paramsStep)) {\n      _errorOnce2(`invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(\", \")}`);\n      return void 0;\n    }\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    const modelParams = {\n      step: paramsStep,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate\n    };\n    return modelParams;\n  }\n  refreshModel(paramsOrStep) {\n    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching()) {\n      return;\n    }\n    const params = typeof paramsOrStep === \"object\" && \"step\" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);\n    if (!params) {\n      return;\n    }\n    if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n      return;\n    }\n    const changedPath = this.createChangePath(params.rowNodeTransactions);\n    this.isRefreshingModel = true;\n    switch (params.step) {\n      case ClientSideRowModelSteps.EVERYTHING:\n        this.doRowGrouping(\n          params.rowNodeTransactions,\n          changedPath,\n          !!params.rowNodesOrderChanged,\n          !!params.afterColumnsChanged\n        );\n      case ClientSideRowModelSteps.FILTER:\n        this.doFilter(changedPath);\n      case ClientSideRowModelSteps.PIVOT:\n        this.doPivot(changedPath);\n      case ClientSideRowModelSteps.AGGREGATE:\n        this.doAggregate(changedPath);\n      case ClientSideRowModelSteps.FILTER_AGGREGATES:\n        this.doFilterAggregates(changedPath);\n      case ClientSideRowModelSteps.SORT:\n        this.doSort(params.rowNodeTransactions, changedPath);\n      case ClientSideRowModelSteps.MAP:\n        this.doRowsToDisplay();\n    }\n    const displayedNodesMapped = this.setRowTopAndRowIndex();\n    this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n    this.isRefreshingModel = false;\n    this.eventService.dispatchEvent({\n      type: \"modelUpdated\",\n      animate: params.animate,\n      keepRenderedRows: params.keepRenderedRows,\n      newData: params.newData,\n      newPage: false,\n      keepUndoRedoStack: params.keepUndoRedoStack\n    });\n  }\n  isEmpty() {\n    const rowsMissing = _missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n    return _missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n  }\n  isRowsToRender() {\n    return _exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n  }\n  getNodesInRangeForSelection(firstInRange, lastInRange) {\n    let started = false;\n    let finished = false;\n    const result = [];\n    const groupsSelectChildren = _getGroupSelectsDescendants(this.gos);\n    this.forEachNodeAfterFilterAndSort((rowNode) => {\n      if (finished) {\n        return;\n      }\n      if (started) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          finished = true;\n          if (rowNode.group && groupsSelectChildren) {\n            result.push(...rowNode.allLeafChildren);\n            return;\n          }\n        }\n      }\n      if (!started) {\n        if (rowNode !== lastInRange && rowNode !== firstInRange) {\n          return;\n        }\n        started = true;\n      }\n      const includeThisNode = !rowNode.group || !groupsSelectChildren;\n      if (includeThisNode) {\n        result.push(rowNode);\n        return;\n      }\n    });\n    return result;\n  }\n  // eslint-disable-next-line\n  setDatasource(datasource) {\n    _errorOnce2(\"should never call setDatasource on clientSideRowController\");\n  }\n  getTopLevelNodes() {\n    return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n  }\n  getRootNode() {\n    return this.rootNode;\n  }\n  getRow(index) {\n    return this.rowsToDisplay[index];\n  }\n  isRowPresent(rowNode) {\n    return this.rowsToDisplay.indexOf(rowNode) >= 0;\n  }\n  getRowIndexAtPixel(pixelToMatch) {\n    if (this.isEmpty() || this.rowsToDisplay.length === 0) {\n      return -1;\n    }\n    let bottomPointer = 0;\n    let topPointer = this.rowsToDisplay.length - 1;\n    if (pixelToMatch <= 0) {\n      return 0;\n    }\n    const lastNode = _last(this.rowsToDisplay);\n    if (lastNode.rowTop <= pixelToMatch) {\n      return this.rowsToDisplay.length - 1;\n    }\n    let oldBottomPointer = -1;\n    let oldTopPointer = -1;\n    while (true) {\n      const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n      const currentRowNode = this.rowsToDisplay[midPointer];\n      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n        return midPointer;\n      }\n      if (currentRowNode.rowTop < pixelToMatch) {\n        bottomPointer = midPointer + 1;\n      } else if (currentRowNode.rowTop > pixelToMatch) {\n        topPointer = midPointer - 1;\n      }\n      const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;\n      if (caughtInInfiniteLoop) {\n        return midPointer;\n      }\n      oldBottomPointer = bottomPointer;\n      oldTopPointer = topPointer;\n    }\n  }\n  isRowInPixel(rowNode, pixelToMatch) {\n    const topPixel = rowNode.rowTop;\n    const bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n    const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n    return pixelInRow;\n  }\n  forEachLeafNode(callback) {\n    if (this.rootNode.allLeafChildren) {\n      this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));\n    }\n  }\n  forEachNode(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...this.rootNode.childrenAfterGroup || []],\n      callback,\n      recursionType: 0 /* Normal */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachNodeAfterFilter(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...this.rootNode.childrenAfterAggFilter || []],\n      callback,\n      recursionType: 1 /* AfterFilter */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [...this.rootNode.childrenAfterSort || []],\n      callback,\n      recursionType: 2 /* AfterFilterAndSort */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  forEachPivotNode(callback, includeFooterNodes = false) {\n    this.recursivelyWalkNodesAndCallback({\n      nodes: [this.rootNode],\n      callback,\n      recursionType: 3 /* PivotNodes */,\n      index: 0,\n      includeFooterNodes\n    });\n  }\n  // iterates through each item in memory, and calls the callback function\n  // nodes - the rowNodes to traverse\n  // callback - the user provided callback\n  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n  // index - works similar to the index in forEach in javascript's array function\n  recursivelyWalkNodesAndCallback(params) {\n    const { nodes, callback, recursionType, includeFooterNodes } = params;\n    let { index } = params;\n    const addFooters = (position) => {\n      const parentNode = nodes[0]?.parent;\n      if (!parentNode)\n        return;\n      const grandTotal = includeFooterNodes && _getGrandTotalRow(this.gos);\n      const isGroupIncludeFooter = _getGroupTotalRowCallback(this.gos);\n      const groupTotal = includeFooterNodes && isGroupIncludeFooter({ node: parentNode });\n      const isRootNode = parentNode === this.rootNode;\n      if (isRootNode) {\n        if (grandTotal === position) {\n          parentNode.createFooter();\n          callback(parentNode.sibling, index++);\n        }\n        return;\n      }\n      if (groupTotal === position) {\n        parentNode.createFooter();\n        callback(parentNode.sibling, index++);\n      }\n    };\n    addFooters(\"top\");\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      callback(node, index++);\n      if (node.hasChildren() && !node.footer) {\n        let nodeChildren = null;\n        switch (recursionType) {\n          case 0 /* Normal */:\n            nodeChildren = node.childrenAfterGroup;\n            break;\n          case 1 /* AfterFilter */:\n            nodeChildren = node.childrenAfterAggFilter;\n            break;\n          case 2 /* AfterFilterAndSort */:\n            nodeChildren = node.childrenAfterSort;\n            break;\n          case 3 /* PivotNodes */:\n            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n            break;\n        }\n        if (nodeChildren) {\n          index = this.recursivelyWalkNodesAndCallback({\n            nodes: [...nodeChildren],\n            callback,\n            recursionType,\n            index,\n            includeFooterNodes\n          });\n        }\n      }\n    }\n    addFooters(\"bottom\");\n    return index;\n  }\n  // it's possible to recompute the aggregate without doing the other parts\n  // + api.refreshClientSideRowModel('aggregate')\n  doAggregate(changedPath) {\n    this.aggregationStage?.execute({ rowNode: this.rootNode, changedPath });\n  }\n  doFilterAggregates(changedPath) {\n    if (this.filterAggregatesStage) {\n      this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath });\n    } else {\n      this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;\n    }\n  }\n  // + gridApi.expandAll()\n  // + gridApi.collapseAll()\n  expandOrCollapseAll(expand) {\n    const usingTreeData = this.gos.get(\"treeData\");\n    const usingPivotMode = this.columnModel.isPivotActive();\n    const recursiveExpandOrCollapse = (rowNodes) => {\n      if (!rowNodes) {\n        return;\n      }\n      rowNodes.forEach((rowNode) => {\n        const actionRow = () => {\n          rowNode.expanded = expand;\n          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n        };\n        if (usingTreeData) {\n          const hasChildren = _exists(rowNode.childrenAfterGroup);\n          if (hasChildren) {\n            actionRow();\n          }\n          return;\n        }\n        if (usingPivotMode) {\n          const notLeafGroup = !rowNode.leafGroup;\n          if (notLeafGroup) {\n            actionRow();\n          }\n          return;\n        }\n        const isRowGroup = rowNode.group;\n        if (isRowGroup) {\n          actionRow();\n        }\n      });\n    };\n    if (this.rootNode) {\n      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n    }\n    this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n    this.eventService.dispatchEvent({\n      type: \"expandOrCollapseAll\",\n      source: expand ? \"expandAll\" : \"collapseAll\"\n    });\n  }\n  doSort(rowNodeTransactions, changedPath) {\n    this.sortStage.execute({\n      rowNode: this.rootNode,\n      rowNodeTransactions,\n      changedPath\n    });\n  }\n  doRowGrouping(rowNodeTransactions, changedPath, rowNodesOrderChanged, afterColumnsChanged) {\n    if (this.groupStage) {\n      if (rowNodeTransactions) {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          rowNodeTransactions,\n          rowNodesOrderChanged,\n          changedPath\n        });\n      } else {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          changedPath,\n          afterColumnsChanged\n        });\n      }\n      if (_getGroupSelectsDescendants(this.gos)) {\n        const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections(\n          \"rowGroupChanged\",\n          changedPath\n        );\n        if (selectionChanged) {\n          this.eventService.dispatchEvent({\n            type: \"selectionChanged\",\n            source: \"rowGroupChanged\"\n          });\n        }\n      }\n    } else {\n      const rootNode = this.rootNode;\n      const sibling = rootNode.sibling;\n      rootNode.childrenAfterGroup = rootNode.allLeafChildren;\n      if (sibling) {\n        sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n      }\n      this.rootNode.updateHasChildren();\n    }\n    if (this.nodeManager.isRowCountReady()) {\n      this.rowCountReady = true;\n      this.eventService.dispatchEventOnce({\n        type: \"rowCountReady\"\n      });\n    }\n  }\n  doFilter(changedPath) {\n    this.filterStage.execute({ rowNode: this.rootNode, changedPath });\n  }\n  doPivot(changedPath) {\n    this.pivotStage?.execute({ rowNode: this.rootNode, changedPath });\n  }\n  getNodeManager() {\n    return this.nodeManager;\n  }\n  getRowNode(id) {\n    const idIsGroup = typeof id == \"string\" && id.indexOf(RowNode2.ID_PREFIX_ROW_GROUP) == 0;\n    if (idIsGroup) {\n      let res = void 0;\n      this.forEachNode((node) => {\n        if (node.id === id) {\n          res = node;\n        }\n      });\n      return res;\n    }\n    return this.nodeManager.getRowNode(id);\n  }\n  // rows: the rows to put into the model\n  setRowData(rowData) {\n    this.selectionService.reset(\"rowDataChanged\");\n    this.nodeManager.setRowData(rowData);\n    if (this.hasStarted) {\n      this.dispatchUpdateEventsAndRefresh();\n    }\n  }\n  dispatchUpdateEventsAndRefresh() {\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdated\"\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      newData: true\n    });\n  }\n  batchUpdateRowData(rowDataTransaction, callback) {\n    if (this.applyAsyncTransactionsTimeout == null) {\n      this.rowDataTransactionBatch = [];\n      const waitMillis = this.gos.get(\"asyncTransactionWaitMillis\");\n      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {\n        if (this.isAlive()) {\n          this.executeBatchUpdateRowData();\n        }\n      }, waitMillis);\n    }\n    this.rowDataTransactionBatch.push({ rowDataTransaction, callback });\n  }\n  flushAsyncTransactions() {\n    if (this.applyAsyncTransactionsTimeout != null) {\n      clearTimeout(this.applyAsyncTransactionsTimeout);\n      this.executeBatchUpdateRowData();\n    }\n  }\n  executeBatchUpdateRowData() {\n    this.valueCache.onDataChanged();\n    const callbackFuncsBound = [];\n    const rowNodeTrans = [];\n    let orderChanged = false;\n    this.rowDataTransactionBatch?.forEach((tranItem) => {\n      const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(tranItem.rowDataTransaction);\n      if (rowsInserted) {\n        orderChanged = true;\n      }\n      rowNodeTrans.push(rowNodeTransaction);\n      if (tranItem.callback) {\n        callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTransaction));\n      }\n    });\n    this.commonUpdateRowData(rowNodeTrans, orderChanged);\n    if (callbackFuncsBound.length > 0) {\n      window.setTimeout(() => {\n        callbackFuncsBound.forEach((func) => func());\n      }, 0);\n    }\n    if (rowNodeTrans.length > 0) {\n      this.eventService.dispatchEvent({\n        type: \"asyncTransactionsFlushed\",\n        results: rowNodeTrans\n      });\n    }\n    this.rowDataTransactionBatch = null;\n    this.applyAsyncTransactionsTimeout = void 0;\n  }\n  /**\n   * Used to apply transaction changes.\n   * Called by gridApi & rowDragFeature\n   */\n  updateRowData(rowDataTran) {\n    this.valueCache.onDataChanged();\n    const { rowNodeTransaction, rowsInserted } = this.nodeManager.updateRowData(rowDataTran);\n    this.commonUpdateRowData([rowNodeTransaction], rowsInserted);\n    return rowNodeTransaction;\n  }\n  /**\n   * Used to apply generated transaction\n   */\n  afterImmutableDataChange(rowNodeTransaction, rowNodesOrderChanged) {\n    this.commonUpdateRowData([rowNodeTransaction], rowNodesOrderChanged);\n  }\n  /**\n   * Common to:\n   * - executeBatchUpdateRowData (batch transactions)\n   * - updateRowData (single transaction)\n   * - afterImmutableDataChange (generated transaction)\n   *\n   * @param rowNodeTrans - the transactions to apply\n   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex\n   */\n  commonUpdateRowData(rowNodeTransactions, rowNodesOrderChanged) {\n    if (!this.hasStarted) {\n      return;\n    }\n    const animate = !this.gos.get(\"suppressAnimationFrame\");\n    this.eventService.dispatchEvent({\n      type: \"rowDataUpdated\"\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      rowNodeTransactions,\n      rowNodesOrderChanged,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      animate\n    });\n  }\n  doRowsToDisplay() {\n    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n  }\n  onRowHeightChanged() {\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      keepEditingRows: true,\n      keepUndoRedoStack: true\n    });\n  }\n  /** This method is debounced. It is used for row auto-height. If we don't debounce,\n   * then the Row Models will end up recalculating each row position\n   * for each row height change and result in the Row Renderer laying out rows.\n   * This is particularly bad if using print layout, and showing eg 1,000 rows,\n   * each row will change it's height, causing Row Model to update 1,000 times.\n   */\n  onRowHeightChangedDebounced() {\n    this.onRowHeightChanged_debounced();\n  }\n  resetRowHeights() {\n    const atLeastOne = this.resetRowHeightsForAllRowNodes();\n    this.rootNode.setRowHeight(this.rootNode.rowHeight, true);\n    if (this.rootNode.sibling) {\n      this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);\n    }\n    if (atLeastOne) {\n      this.onRowHeightChanged();\n    }\n  }\n  resetRowHeightsForAllRowNodes() {\n    let atLeastOne = false;\n    this.forEachNode((rowNode) => {\n      rowNode.setRowHeight(rowNode.rowHeight, true);\n      const detailNode = rowNode.detailNode;\n      if (detailNode) {\n        detailNode.setRowHeight(detailNode.rowHeight, true);\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);\n      }\n      atLeastOne = true;\n    });\n    return atLeastOne;\n  }\n  onGridStylesChanges(e) {\n    if (e.rowHeightChanged) {\n      if (this.columnModel.isAutoRowHeightActive()) {\n        return;\n      }\n      this.resetRowHeights();\n    }\n  }\n  onGridReady() {\n    if (this.hasStarted) {\n      return;\n    }\n    this.setInitialData();\n  }\n  isRowDataLoaded() {\n    return this.rowCountReady;\n  }\n  destroy() {\n    super.destroy();\n    this.clearHighlightedRow();\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModelApi.ts\nimport { _warnOnce as _warnOnce2 } from \"@ag-grid-community/core\";\nfunction onGroupExpandedOrCollapsed(beans) {\n  beans.expansionService.onGroupExpandedOrCollapsed();\n}\nfunction refreshClientSideRowModel(beans, step) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.refreshModel(step);\n}\nfunction isRowDataEmpty(beans) {\n  return beans.rowModelHelperService?.getClientSideRowModel()?.isEmpty() ?? true;\n}\nfunction forEachLeafNode(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachLeafNode(callback);\n}\nfunction forEachNodeAfterFilter(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilter(callback);\n}\nfunction forEachNodeAfterFilterAndSort(beans, callback) {\n  beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilterAndSort(callback);\n}\nfunction resetRowHeights(beans) {\n  if (beans.columnModel.isAutoRowHeightActive()) {\n    _warnOnce2(\"calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.\");\n    return;\n  }\n  beans.rowModelHelperService?.getClientSideRowModel()?.resetRowHeights();\n}\nfunction applyTransaction(beans, rowDataTransaction) {\n  return beans.frameworkOverrides.wrapIncoming(\n    () => beans.rowModelHelperService?.getClientSideRowModel()?.updateRowData(rowDataTransaction)\n  );\n}\nfunction applyTransactionAsync(beans, rowDataTransaction, callback) {\n  beans.frameworkOverrides.wrapIncoming(\n    () => beans.rowModelHelperService?.getClientSideRowModel()?.batchUpdateRowData(rowDataTransaction, callback)\n  );\n}\nfunction flushAsyncTransactions(beans) {\n  beans.frameworkOverrides.wrapIncoming(\n    () => beans.rowModelHelperService?.getClientSideRowModel()?.flushAsyncTransactions()\n  );\n}\nfunction getBestCostNodeSelection(beans) {\n  return beans.selectionService.getBestCostNodeSelection();\n}\n\n// community-modules/client-side-row-model/src/clientSideRowModel/filterStage.ts\nimport { BeanStub as BeanStub2 } from \"@ag-grid-community/core\";\nvar FilterStage = class extends BeanStub2 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"filterStage\";\n  }\n  wireBeans(beans) {\n    this.filterManager = beans.filterManager;\n  }\n  execute(params) {\n    const { changedPath } = params;\n    this.filter(changedPath);\n  }\n  filter(changedPath) {\n    const filterActive = !!this.filterManager?.isChildFilterPresent();\n    this.filterNodes(filterActive, changedPath);\n  }\n  filterNodes(filterActive, changedPath) {\n    const filterCallback = (rowNode, includeChildNodes) => {\n      if (rowNode.hasChildren()) {\n        if (filterActive && !includeChildNodes) {\n          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {\n            const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;\n            const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });\n            return passBecauseChildren || passBecauseDataPasses;\n          });\n        } else {\n          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n        }\n      } else {\n        rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;\n      }\n    };\n    if (this.doingTreeDataFiltering()) {\n      const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {\n        if (rowNode.childrenAfterGroup) {\n          for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n            const childNode = rowNode.childrenAfterGroup[i];\n            const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });\n            if (childNode.childrenAfterGroup) {\n              treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);\n            } else {\n              filterCallback(childNode, foundInParent);\n            }\n          }\n        }\n        filterCallback(rowNode, alreadyFoundInParent);\n      };\n      const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);\n      changedPath.executeFromRootNode(treeDataFilterCallback);\n    } else {\n      const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);\n      changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);\n    }\n  }\n  doingTreeDataFiltering() {\n    return this.gos.get(\"treeData\") && !this.gos.get(\"excludeChildrenWhenTreeDataFiltering\");\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/flattenStage.ts\nimport {\n  BeanStub as BeanStub3,\n  RowNode as RowNode3,\n  _exists as _exists2,\n  _getGrandTotalRow as _getGrandTotalRow2,\n  _getGroupTotalRowCallback as _getGroupTotalRowCallback2,\n  _isGroupMultiAutoColumn,\n  _missingOrEmpty as _missingOrEmpty3\n} from \"@ag-grid-community/core\";\nvar FlattenStage = class extends BeanStub3 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"flattenStage\";\n  }\n  wireBeans(beans) {\n    this.beans = beans;\n    this.columnModel = beans.columnModel;\n  }\n  execute(params) {\n    const rootNode = params.rowNode;\n    const result = [];\n    const skipLeafNodes = this.columnModel.isPivotMode();\n    const showRootNode = skipLeafNodes && rootNode.leafGroup;\n    const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n    const details = this.getFlattenDetails();\n    this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);\n    const atLeastOneRowPresent = result.length > 0;\n    const includeGrandTotalRow = !showRootNode && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n    atLeastOneRowPresent && details.grandTotalRow;\n    if (includeGrandTotalRow) {\n      rootNode.createFooter();\n      const addToTop = details.grandTotalRow === \"top\";\n      this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);\n    }\n    return result;\n  }\n  getFlattenDetails() {\n    const groupRemoveSingleChildren = this.gos.get(\"groupRemoveSingleChildren\");\n    const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gos.get(\"groupRemoveLowestSingleChildren\");\n    return {\n      groupRemoveLowestSingleChildren,\n      groupRemoveSingleChildren,\n      isGroupMultiAutoColumn: _isGroupMultiAutoColumn(this.gos),\n      hideOpenParents: this.gos.get(\"groupHideOpenParents\"),\n      grandTotalRow: _getGrandTotalRow2(this.gos),\n      groupTotalRow: _getGroupTotalRowCallback2(this.gos)\n    };\n  }\n  recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {\n    if (_missingOrEmpty3(rowsToFlatten)) {\n      return;\n    }\n    for (let i = 0; i < rowsToFlatten.length; i++) {\n      const rowNode = rowsToFlatten[i];\n      const isParent = rowNode.hasChildren();\n      const isSkippedLeafNode = skipLeafNodes && !isParent;\n      const isRemovedSingleChildrenGroup = details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;\n      const isRemovedLowestSingleChildrenGroup = details.groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;\n      const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n      const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;\n      const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n      if (thisRowShouldBeRendered) {\n        this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);\n      }\n      if (skipLeafNodes && rowNode.leafGroup) {\n        continue;\n      }\n      if (isParent) {\n        const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n        if (rowNode.expanded || excludedParent) {\n          const doesRowShowFooter = details.groupTotalRow({ node: rowNode });\n          if (!doesRowShowFooter) {\n            rowNode.destroyFooter();\n          }\n          const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n          if (doesRowShowFooter === \"top\") {\n            rowNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n          }\n          this.recursivelyAddToRowsToDisplay(\n            details,\n            rowNode.childrenAfterSort,\n            result,\n            skipLeafNodes,\n            uiLevelForChildren\n          );\n          if (doesRowShowFooter === \"bottom\") {\n            rowNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n          }\n        }\n      } else if (rowNode.master && rowNode.expanded) {\n        const detailNode = this.createDetailNode(rowNode);\n        this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);\n      }\n    }\n  }\n  // duplicated method, it's also in floatingRowModel\n  addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel, addToTop) {\n    if (addToTop) {\n      result.unshift(rowNode);\n    } else {\n      result.push(rowNode);\n    }\n    rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);\n  }\n  createDetailNode(masterNode) {\n    if (_exists2(masterNode.detailNode)) {\n      return masterNode.detailNode;\n    }\n    const detailNode = new RowNode3(this.beans);\n    detailNode.detail = true;\n    detailNode.selectable = false;\n    detailNode.parent = masterNode;\n    if (_exists2(masterNode.id)) {\n      detailNode.id = \"detail_\" + masterNode.id;\n    }\n    detailNode.data = masterNode.data;\n    detailNode.level = masterNode.level + 1;\n    masterNode.detailNode = detailNode;\n    return detailNode;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/immutableService.ts\nimport {\n  BeanStub as BeanStub4,\n  _errorOnce as _errorOnce3,\n  _exists as _exists3,\n  _getRowIdCallback as _getRowIdCallback2,\n  _isClientSideRowModel,\n  _iterateObject\n} from \"@ag-grid-community/core\";\nvar ImmutableService = class extends BeanStub4 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"immutableService\";\n  }\n  wireBeans(beans) {\n    this.rowModel = beans.rowModel;\n    this.selectionService = beans.selectionService;\n  }\n  postConstruct() {\n    if (_isClientSideRowModel(this.gos)) {\n      this.clientSideRowModel = this.rowModel;\n      this.addManagedPropertyListener(\"rowData\", () => this.onRowDataUpdated());\n    }\n  }\n  isActive() {\n    const getRowIdProvided = this.gos.exists(\"getRowId\");\n    const resetRowDataOnUpdate = this.gos.get(\"resetRowDataOnUpdate\");\n    if (resetRowDataOnUpdate) {\n      return false;\n    }\n    return getRowIdProvided;\n  }\n  setRowData(rowData) {\n    const rowDataTransaction = this.createTransactionForRowData(rowData);\n    if (!rowDataTransaction) {\n      return;\n    }\n    const nodeManager = this.clientSideRowModel.getNodeManager();\n    const { rowNodeTransaction, rowsInserted } = nodeManager.updateRowData(rowDataTransaction);\n    let orderChanged = false;\n    const suppressSortOrder = this.gos.get(\"suppressMaintainUnsortedOrder\");\n    if (!suppressSortOrder) {\n      orderChanged = nodeManager.updateRowOrderFromRowData(rowData);\n    }\n    this.clientSideRowModel.afterImmutableDataChange(rowNodeTransaction, orderChanged || rowsInserted);\n  }\n  /** Converts the setRowData() command to a transaction */\n  createTransactionForRowData(rowData) {\n    if (!_isClientSideRowModel(this.gos)) {\n      _errorOnce3(\"ImmutableService only works with ClientSideRowModel\");\n      return null;\n    }\n    const getRowIdFunc = _getRowIdCallback2(this.gos);\n    if (getRowIdFunc == null) {\n      _errorOnce3(\"ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!\");\n      return null;\n    }\n    const existingNodesMap = this.clientSideRowModel.getNodeManager().getCopyOfNodesMap();\n    const remove = [];\n    const update = [];\n    const add = [];\n    if (_exists3(rowData)) {\n      rowData.forEach((data) => {\n        const id = getRowIdFunc({ data, level: 0 });\n        const existingNode = existingNodesMap[id];\n        if (existingNode) {\n          const dataHasChanged = existingNode.data !== data;\n          if (dataHasChanged) {\n            update.push(data);\n          }\n          existingNodesMap[id] = void 0;\n        } else {\n          add.push(data);\n        }\n      });\n    }\n    _iterateObject(existingNodesMap, (id, rowNode) => {\n      if (rowNode) {\n        remove.push(rowNode.data);\n      }\n    });\n    return { remove, update, add };\n  }\n  onRowDataUpdated() {\n    const rowData = this.gos.get(\"rowData\");\n    if (!rowData) {\n      return;\n    }\n    if (this.isActive()) {\n      this.setRowData(rowData);\n    } else {\n      this.selectionService.reset(\"rowDataChanged\");\n      this.clientSideRowModel.setRowData(rowData);\n    }\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/sortService.ts\nimport { BeanStub as BeanStub5, _errorOnce as _errorOnce4, _missing as _missing2, _warnOnce as _warnOnce3 } from \"@ag-grid-community/core\";\nvar SortService = class extends BeanStub5 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sortService\";\n  }\n  wireBeans(beans) {\n    this.columnModel = beans.columnModel;\n    this.funcColsService = beans.funcColsService;\n    this.rowNodeSorter = beans.rowNodeSorter;\n    this.showRowGroupColsService = beans.showRowGroupColsService;\n  }\n  sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {\n    const groupMaintainOrder = this.gos.get(\"groupMaintainOrder\");\n    const groupColumnsPresent = this.columnModel.getCols().some((c) => c.isRowGroupActive());\n    let allDirtyNodes = {};\n    if (useDeltaSort && rowNodeTransactions) {\n      allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);\n    }\n    const isPivotMode = this.columnModel.isPivotMode();\n    const postSortFunc = this.gos.getCallback(\"postSortRows\");\n    const callback = (rowNode) => {\n      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);\n      const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;\n      const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n      if (skipSortingGroups) {\n        const nextGroup = this.funcColsService.getRowGroupColumns()?.[rowNode.level + 1];\n        const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;\n        const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);\n        if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {\n          const indexedOrders = {};\n          rowNode.childrenAfterSort.forEach((node, idx) => {\n            indexedOrders[node.id] = idx;\n          });\n          childrenToBeSorted.sort(\n            (row1, row2) => (indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0)\n          );\n        }\n        rowNode.childrenAfterSort = childrenToBeSorted;\n      } else if (!sortActive || skipSortingPivotLeafs) {\n        rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);\n      } else if (useDeltaSort) {\n        rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);\n      } else {\n        rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);\n      }\n      if (rowNode.sibling) {\n        rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n      }\n      this.updateChildIndexes(rowNode);\n      if (postSortFunc) {\n        const params = { nodes: rowNode.childrenAfterSort };\n        postSortFunc(params);\n      }\n    };\n    if (changedPath) {\n      changedPath.forEachChangedNodeDepthFirst(callback);\n    }\n    this.updateGroupDataForHideOpenParents(changedPath);\n  }\n  calculateDirtyNodes(rowNodeTransactions) {\n    const dirtyNodes = {};\n    const addNodesFunc = (rowNodes) => {\n      if (rowNodes) {\n        rowNodes.forEach((rowNode) => dirtyNodes[rowNode.id] = true);\n      }\n    };\n    if (rowNodeTransactions) {\n      rowNodeTransactions.forEach((tran) => {\n        addNodesFunc(tran.add);\n        addNodesFunc(tran.update);\n        addNodesFunc(tran.remove);\n      });\n    }\n    return dirtyNodes;\n  }\n  doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {\n    const unsortedRows = rowNode.childrenAfterAggFilter;\n    const oldSortedRows = rowNode.childrenAfterSort;\n    if (!oldSortedRows) {\n      return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);\n    }\n    const untouchedRowsMap = {};\n    const touchedRows = [];\n    unsortedRows.forEach((row) => {\n      if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) {\n        touchedRows.push(row);\n      } else {\n        untouchedRowsMap[row.id] = true;\n      }\n    });\n    const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRowsMap[child.id]);\n    const mapNodeToSortedNode = (rowNode2, pos) => ({\n      currentPos: pos,\n      rowNode: rowNode2\n    });\n    const sortedChangedRows = touchedRows.map(mapNodeToSortedNode).sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));\n    return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(\n      ({ rowNode: rowNode2 }) => rowNode2\n    );\n  }\n  // Merge two sorted arrays into each other\n  mergeSortedArrays(sortOptions, arr1, arr2) {\n    const res = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n      const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n      if (compareResult < 0) {\n        res.push(arr1[i++]);\n      } else {\n        res.push(arr2[j++]);\n      }\n    }\n    while (i < arr1.length) {\n      res.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n      res.push(arr2[j++]);\n    }\n    return res;\n  }\n  updateChildIndexes(rowNode) {\n    if (_missing2(rowNode.childrenAfterSort)) {\n      return;\n    }\n    const listToSort = rowNode.childrenAfterSort;\n    for (let i = 0; i < listToSort.length; i++) {\n      const child = listToSort[i];\n      const firstChild = i === 0;\n      const lastChild = i === rowNode.childrenAfterSort.length - 1;\n      child.setFirstChild(firstChild);\n      child.setLastChild(lastChild);\n      child.setChildIndex(i);\n    }\n  }\n  updateGroupDataForHideOpenParents(changedPath) {\n    if (!this.gos.get(\"groupHideOpenParents\")) {\n      return;\n    }\n    if (this.gos.get(\"treeData\")) {\n      _warnOnce3(\n        `The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`\n      );\n      return false;\n    }\n    const callback = (rowNode) => {\n      this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n      rowNode.childrenAfterSort.forEach((child) => {\n        if (child.hasChildren()) {\n          callback(child);\n        }\n      });\n    };\n    if (changedPath) {\n      changedPath.executeFromRootNode((rowNode) => callback(rowNode));\n    }\n  }\n  pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {\n    if (!this.gos.get(\"groupHideOpenParents\") || _missing2(rowNodes)) {\n      return;\n    }\n    rowNodes.forEach((childRowNode) => {\n      const groupDisplayCols = this.showRowGroupColsService?.getShowRowGroupCols() ?? [];\n      groupDisplayCols.forEach((groupDisplayCol) => {\n        const showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n        if (typeof showRowGroup !== \"string\") {\n          _errorOnce4(\n            \"groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup\"\n          );\n          return;\n        }\n        const displayingGroupKey = showRowGroup;\n        const rowGroupColumn = this.columnModel.getColDefCol(displayingGroupKey);\n        const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n        if (thisRowNodeMatches) {\n          return;\n        }\n        if (clearOperation) {\n          childRowNode.setGroupValue(groupDisplayCol.getId(), void 0);\n        } else {\n          const parentToStealFrom = this.getFirstChildOfFirstChild(childRowNode, rowGroupColumn);\n          if (parentToStealFrom) {\n            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n          }\n        }\n      });\n    });\n  }\n  getFirstChildOfFirstChild(node, rowGroupColumn) {\n    let currentRowNode = node;\n    while (currentRowNode) {\n      const parentRowNode = currentRowNode.parent;\n      if (parentRowNode && currentRowNode.firstChild) {\n        if (parentRowNode.rowGroupColumn === rowGroupColumn) {\n          return parentRowNode;\n        }\n      } else {\n        return null;\n      }\n      currentRowNode = parentRowNode;\n    }\n    return null;\n  }\n};\n\n// community-modules/client-side-row-model/src/clientSideRowModel/sortStage.ts\nimport { BeanStub as BeanStub6, _exists as _exists4, _isColumnsSortingCoupledToGroup } from \"@ag-grid-community/core\";\nvar SortStage = class extends BeanStub6 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sortStage\";\n  }\n  wireBeans(beans) {\n    this.sortService = beans.sortService;\n    this.sortController = beans.sortController;\n  }\n  execute(params) {\n    const sortOptions = this.sortController.getSortOptions();\n    const sortActive = _exists4(sortOptions) && sortOptions.length > 0;\n    const deltaSort = sortActive && _exists4(params.rowNodeTransactions) && // in time we can remove this check, so that delta sort is always\n    // on if transactions are present. it's off for now so that we can\n    // selectively turn it on and test it with some select users before\n    // rolling out to everyone.\n    this.gos.get(\"deltaSort\");\n    const sortContainsGroupColumns = sortOptions.some((opt) => {\n      const isSortingCoupled = _isColumnsSortingCoupledToGroup(this.gos);\n      if (isSortingCoupled) {\n        return opt.column.isPrimary() && opt.column.isRowGroupActive();\n      }\n      return !!opt.column.getColDef().showRowGroup;\n    });\n    this.sortService.sort(\n      sortOptions,\n      sortActive,\n      deltaSort,\n      params.rowNodeTransactions,\n      params.changedPath,\n      sortContainsGroupColumns\n    );\n  }\n};\n\n// community-modules/client-side-row-model/src/version.ts\nvar VERSION = \"32.3.3\";\n\n// community-modules/client-side-row-model/src/clientSideRowModelModule.ts\nvar ClientSideRowModelCoreModule = _defineModule({\n  version: VERSION,\n  moduleName: `${ModuleNames.ClientSideRowModelModule}-core`,\n  rowModel: \"clientSide\",\n  beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, ImmutableService]\n});\nvar ClientSideRowModelApiModule = _defineModule({\n  version: VERSION,\n  moduleName: `${ModuleNames.ClientSideRowModelModule}-api`,\n  beans: [RowModelHelperService],\n  apiFunctions: {\n    onGroupExpandedOrCollapsed,\n    refreshClientSideRowModel,\n    isRowDataEmpty,\n    forEachLeafNode,\n    forEachNodeAfterFilter,\n    forEachNodeAfterFilterAndSort,\n    resetRowHeights,\n    applyTransaction,\n    applyTransactionAsync,\n    flushAsyncTransactions,\n    getBestCostNodeSelection\n  },\n  dependantModules: [ClientSideRowModelCoreModule, _CsrmSsrmSharedApiModule]\n});\nvar ClientSideRowModelModule = _defineModule({\n  version: VERSION,\n  moduleName: ModuleNames.ClientSideRowModelModule,\n  dependantModules: [ClientSideRowModelCoreModule, ClientSideRowModelApiModule]\n});\nexport {\n  ClientSideRowModelModule\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}